#!/usr/bin/env python3
"""
ç´™é¢äº¤æ˜“ç³»çµ± (Paper Trading System)
==================================

åŠŸèƒ½ï¼š
1. ä½¿ç”¨çœŸå¯¦å¸‚å ´æ•¸æ“šï¼ˆBinance WebSocketï¼‰
2. æ¨¡æ“¬è¨‚å–®åŸ·è¡Œï¼ˆå«æ»‘é»ã€æ‰‹çºŒè²»ã€è³‡é‡‘è²»ç‡ï¼‰
3. å¤šç¨®é¢¨æ§æ¨¡å¼å°æ¯”æ¸¬è©¦
4. å®Œæ•´è¨‚å–®ç°¿è¨˜éŒ„ï¼ˆJSON æ ¼å¼ï¼‰
5. äº‹å¾Œç¸¾æ•ˆåˆ†æ

é¢¨æ§æ¨¡å¼ï¼š
- Mode 0-10: å‹•æ…‹è¼‰å…¥è‡ª config/trading_strategies.json
- æ”¯æ´ç¨ç«‹å•Ÿç”¨/ç¦ç”¨æ¯å€‹ç­–ç•¥
- æ¯å€‹ç­–ç•¥æœ‰ç¨ç«‹çš„åƒæ•¸é…ç½®

é‡è¦æ€§ï¼šâ­â­â­â­â­
ç”¨é€”ï¼šé©—è­‰å¤šç¨®ç­–ç•¥çš„å¯¦éš›è¡¨ç¾
"""

import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent))

import asyncio
import json
import time
from datetime import datetime
from collections import deque
from typing import Dict, List, Optional, Tuple
from urllib.request import urlopen
from urllib.parse import urlencode
import websockets
import numpy as np

from src.exchange.obi_calculator import OBICalculator
from src.exchange.signed_volume_tracker import SignedVolumeTracker
from src.exchange.vpin_calculator import VPINCalculator
from src.exchange.spread_depth_monitor import SpreadDepthMonitor
from src.strategy.layered_trading_engine import LayeredTradingEngine
from src.strategy.strategy_manager import StrategyManager
from src.utils.config_monitor import ConfigMonitor


class SimulatedOrder:
    """æ¨¡æ“¬è¨‚å–®ï¼ˆå®Œæ•´è¨˜éŒ„ï¼‰"""
    
    # äº¤æ˜“åƒæ•¸ï¼ˆçœŸå¯¦ Binance è²»ç‡ï¼‰
    MAKER_FEE = 0.0002  # 0.02%
    TAKER_FEE = 0.0005  # 0.05%
    FUNDING_RATE_HOURLY = 0.00003  # ~0.003%/hr
    SLIPPAGE_BPS = 2  # 2 bps æ»‘é»
    
    def __init__(self, order_id: int, timestamp: float, price: float,
                 signal: dict, market_data: dict, mode: str,
                 capital: float = 100.0, leverage: int = 5):
        # åŸºæœ¬ä¿¡æ¯
        self.order_id = order_id
        self.timestamp = timestamp
        self.entry_time = datetime.fromtimestamp(timestamp / 1000)
        self.mode = mode  # é¢¨æ§æ¨¡å¼
        
        # å¸‚å ´æ•¸æ“šå¿«ç…§
        self.entry_price = price
        self.market_data = market_data.copy()
        self.signal = signal.copy()
        self.entry_obi = market_data.get('obi', 0)  # è¨˜éŒ„é€²å ´ OBI
        
        # æ±ºç­–ä¿¡æ¯
        self.direction = signal['direction']  # LONG/SHORT/NEUTRAL
        self.confidence = signal['confidence']
        self.risk_level = market_data.get('risk_level', 'UNKNOWN')
        self.can_trade = True  # æœƒåœ¨å¤–éƒ¨è¨­ç½®
        self.blocked_reasons = []
        
        # å€‰ä½ä¿¡æ¯
        self.capital = capital
        self.leverage = leverage  # ä½¿ç”¨å¤–éƒ¨å‚³å…¥çš„æ§“æ¡¿
        self.size = self._determine_size()
        self.position_value = capital * self.size * self.leverage
        
        # æ­¢ææ­¢ç›ˆï¼ˆæ ¹æ“šé¢¨éšªç­‰ç´šèª¿æ•´ï¼‰
        self.stop_loss_pct, self.take_profit_pct = self._determine_risk_params()
        
        # è¨ˆç®—å¯¦éš›åƒ¹æ ¼ï¼ˆå«æ»‘é»ï¼‰
        slippage = self.SLIPPAGE_BPS / 10000
        if self.direction == "LONG":
            self.actual_entry_price = price * (1 + slippage)
        else:  # SHORT
            self.actual_entry_price = price * (1 - slippage)
        
        # æ‰‹çºŒè²»
        self.entry_fee = self.position_value * self.TAKER_FEE
        
        # å¹³å€‰ä¿¡æ¯ï¼ˆç¨å¾Œå¡«å¯«ï¼‰
        self.exit_price: Optional[float] = None
        self.exit_time: Optional[datetime] = None
        self.exit_reason: Optional[str] = None
        self.holding_seconds: Optional[float] = None
        self.exit_fee: Optional[float] = None
        self.funding_fee: Optional[float] = None
        self.pnl_usdt: Optional[float] = None
        self.pnl_pct: Optional[float] = None
        self.roi: Optional[float] = None
        
        # ç‹€æ…‹
        self.status = "OPEN"  # OPEN/CLOSED/BLOCKED
        
        # Mode 13 è¿½è¹¤æ­¢æç‹€æ…‹
        self.peak_pnl_pct = 0.0  # è¨˜éŒ„æœ€é«˜ç›ˆåˆ©ç™¾åˆ†æ¯”
        self.trailing_stop_active = False  # è¿½è¹¤æ­¢ææ˜¯å¦å•Ÿå‹•
    
    def _determine_size(self) -> float:
        """æ ¹æ“šä¿¡å¿ƒåº¦æ±ºå®šå€‰ä½å¤§å°"""
        confidence = self.confidence
        
        if confidence > 0.8:
            return 0.8  # æ¿€é€² 80%
        elif confidence > 0.6:
            return 0.5  # ä¸­ç­‰ 50%
        else:
            return 0.3  # ä¿å®ˆ 30%
    
    def _determine_risk_params(self) -> Tuple[float, float]:
        """æ ¹æ“šé¢¨éšªç­‰ç´šæ±ºå®šæ­¢ææ­¢ç›ˆ"""
        risk = self.market_data.get('risk_level', 'UNKNOWN')
        leverage = self.leverage
        
        if risk in ['SAFE', 'UNKNOWN']:
            return (5.0, 8.0)  # 5% æ­¢æ, 8% æ­¢ç›ˆ
        elif risk == 'WARNING':
            return (8.0, 12.0)  # 8% æ­¢æ, 12% æ­¢ç›ˆ
        else:  # DANGER/CRITICAL
            return (10.0, 15.0)  # 10% æ­¢æ, 15% æ­¢ç›ˆ
    
    def check_exit(self, current_price: float, current_signal: dict, current_obi: float = 0, market_data: dict = None) -> Optional[str]:
        """æª¢æŸ¥æ˜¯å¦æ‡‰è©²å¹³å€‰"""
        if self.status != "OPEN":
            return None
        
        # è¨ˆç®—æœªå¯¦ç¾ç›ˆè™§
        if self.direction == "LONG":
            price_change_pct = ((current_price - self.actual_entry_price) / 
                               self.actual_entry_price) * 100
            pnl_pct = price_change_pct * self.leverage
        else:  # SHORT
            price_change_pct = ((self.actual_entry_price - current_price) / 
                               self.actual_entry_price) * 100
            pnl_pct = price_change_pct * self.leverage
        
        # Mode 13 ç‰¹æ®Šé‚è¼¯ï¼šProfit-Running ç­–ç•¥
        if self.mode == 'mode_13_adaptive':
            # æ›´æ–°å³°å€¼ç›ˆåˆ©
            if pnl_pct > self.peak_pnl_pct:
                self.peak_pnl_pct = pnl_pct
            
            # å¾ç­–ç•¥é…ç½®ç²å–åƒæ•¸
            trailing_trigger = 0.01  # 1% è§¸ç™¼è¿½è¹¤æ­¢æ
            trailing_distance = 0.003  # 0.3% å›æ’¤è·é›¢
            max_hold_time = 7200  # 2å°æ™‚
            min_hold_time = 60  # 60ç§’
            
            # è¨ˆç®—æŒå€‰æ™‚é–“
            current_hold_time = (time.time() * 1000 - self.timestamp) / 1000
            
            # 1. æœ€å°æŒå€‰æ™‚é–“æª¢æŸ¥ï¼ˆé¿å…éæ—©å¹³å€‰ï¼‰
            if current_hold_time < min_hold_time:
                return None
            
            # 2. é”åˆ°æ­¢ç›ˆç›®æ¨™ (2%)
            if pnl_pct >= self.take_profit_pct:
                return "TAKE_PROFIT"
            
            # 3. è¿½è¹¤æ­¢æé‚è¼¯
            if self.peak_pnl_pct >= trailing_trigger:
                self.trailing_stop_active = True
            
            if self.trailing_stop_active:
                # å¦‚æœå¾å³°å€¼å›æ’¤è¶…é trailing_distanceï¼Œå¹³å€‰
                if pnl_pct < self.peak_pnl_pct - trailing_distance:
                    return "TRAILING_STOP"
            
            # 4. æ­¢æ (0.8%)
            if pnl_pct <= -self.stop_loss_pct:
                return "STOP_LOSS"
            
            # 5. æœ€å¤§æŒå€‰æ™‚é–“ï¼ˆ2å°æ™‚ï¼‰ä¸”ç›ˆåˆ©ä¸è¶³ 0.5%
            if current_hold_time > max_hold_time and pnl_pct < 0.005:
                return "TIME_STOP"
            
            # 6. å¼·çƒˆåå‘ä¿¡è™Ÿ
            if current_signal['direction'] != self.direction and \
               current_signal['direction'] != 'NEUTRAL' and \
               current_signal['confidence'] > 0.7:
                return "REVERSE_SIGNAL"
            
            return None
        
        # å…¶ä»–æ¨¡å¼çš„å„ªåŒ–é‚è¼¯
        # è¨ˆç®—æŒå€‰æ™‚é–“ï¼ˆæ‰€æœ‰æ¨¡å¼éƒ½éœ€è¦ï¼‰
        current_hold_time = (time.time() * 1000 - self.timestamp) / 1000
        
        # 1. æª¢æŸ¥æ­¢æï¼ˆå„ªå…ˆç´šæœ€é«˜ï¼‰
        if pnl_pct <= -self.stop_loss_pct:
            return "STOP_LOSS"
        
        # 2. æª¢æŸ¥æ­¢ç›ˆï¼ˆå„ªå…ˆç´šç¬¬äºŒï¼‰
        if pnl_pct >= self.take_profit_pct:
            return "TAKE_PROFIT"
        
        # 3. æª¢æŸ¥ VPIN çªç„¶é£†å‡ï¼ˆæ–°å¢ï¼šé«˜æ¯’æ€§é¢¨éšªï¼‰
        if market_data:
            vpin = market_data.get('vpin', 0.3)
            vpin_spike_threshold = 0.8  # VPIN > 0.8 è¦–ç‚ºæ¥µé«˜é¢¨éšª
            if vpin > vpin_spike_threshold and pnl_pct > 0:  # åªåœ¨æœ‰ç›ˆåˆ©æ™‚å›  VPIN å¹³å€‰
                return "VPIN_SPIKE"
        
        # 4. æª¢æŸ¥æœ€å¤§æŒå€‰æ™‚é–“
        max_hold_time = 7200  # 2å°æ™‚
        if current_hold_time > max_hold_time:
            # è¶…éæœ€å¤§æ™‚é–“ä¸”æœªé”é æœŸç›ˆåˆ©
            if pnl_pct < 0.005:  # 0.5% æœ€å°ç›®æ¨™
                return "TIME_STOP"
        
        # 5. æª¢æŸ¥å¼·çƒˆåå‘ä¿¡è™Ÿï¼ˆæé«˜ä¿¡å¿ƒåº¦é–¾å€¼ï¼Œé¿å…é »ç¹åå‘ï¼‰
        # æ”¹é€²ï¼šéœ€è¦éå¸¸å¼·çš„ä¿¡è™Ÿï¼ˆconfidence > 0.8ï¼‰æ‰åå‘
        if current_signal['direction'] != self.direction and \
           current_signal['direction'] != 'NEUTRAL' and \
           current_signal['confidence'] > 0.8:
            return "REVERSE_SIGNAL"
        
        # 6. Mode 0 ç‰¹æ®Š: ä¿æŒåŸæœ‰å¿«é€Ÿåå‘é‚è¼¯ï¼ˆä½œç‚ºåŸºæº–ï¼‰
        if self.mode == 'mode_0_baseline':
            # LONG æŒå€‰: å¦‚æœé€²å ´æ™‚ OBI > 0 (è²·ç›¤å¼·),ç¾åœ¨ OBI < -0.3 (è³£ç›¤å¼·),å¹³å€‰
            if self.direction == "LONG" and self.entry_obi > 0 and current_obi < -0.3:
                return "REVERSE_SIGNAL"
            # SHORT æŒå€‰: å¦‚æœé€²å ´æ™‚ OBI < 0 (è³£ç›¤å¼·),ç¾åœ¨ OBI > 0.3 (è²·ç›¤å¼·),å¹³å€‰
            elif self.direction == "SHORT" and self.entry_obi < 0 and current_obi > 0.3:
                return "REVERSE_SIGNAL"
        
        return None
    
    def close(self, exit_price: float, reason: str, timestamp: float):
        """å¹³å€‰ä¸¦è¨ˆç®—å®Œæ•´ç›ˆè™§"""
        self.exit_price = exit_price
        self.exit_time = datetime.fromtimestamp(timestamp / 1000)
        self.exit_reason = reason
        self.holding_seconds = (timestamp - self.timestamp) / 1000
        self.status = "CLOSED"
        
        # è¨ˆç®—æŒå€‰æ™‚é–“ï¼ˆå°æ™‚ï¼‰
        holding_hours = self.holding_seconds / 3600
        
        # 1. è¨ˆç®—è³‡é‡‘è²»ç‡
        self.funding_fee = self.position_value * self.FUNDING_RATE_HOURLY * holding_hours
        
        # 2. è¨ˆç®—å‡ºå ´æ»‘é»
        slippage = self.SLIPPAGE_BPS / 10000
        if self.direction == "LONG":
            actual_exit_price = exit_price * (1 - slippage)
        else:
            actual_exit_price = exit_price * (1 + slippage)
        
        # 3. è¨ˆç®—å‡ºå ´æ‰‹çºŒè²»
        self.exit_fee = self.position_value * self.TAKER_FEE
        
        # 4. è¨ˆç®—åƒ¹æ ¼ç›ˆè™§ï¼ˆUSDTï¼‰
        if self.direction == "LONG":
            price_pnl = ((actual_exit_price - self.actual_entry_price) / 
                        self.actual_entry_price) * self.position_value
        else:  # SHORT
            price_pnl = ((self.actual_entry_price - actual_exit_price) / 
                        self.actual_entry_price) * self.position_value
        
        # 5. ç¸½ç›ˆè™§ï¼ˆæ‰£é™¤æ‰€æœ‰è²»ç”¨ï¼‰
        self.total_fees = self.entry_fee + self.exit_fee + self.funding_fee
        self.pnl_usdt = price_pnl - self.total_fees
        
        # 6. è¨ˆç®— ROIï¼ˆç›¸å°æ–¼æœ¬é‡‘ï¼‰
        self.roi = (self.pnl_usdt / self.capital) * 100
        
        # 7. è¨ˆç®—ç›ˆè™§ç™¾åˆ†æ¯”ï¼ˆç›¸å°æ–¼å€‰ä½åƒ¹å€¼ï¼‰
        self.pnl_pct = (self.pnl_usdt / self.position_value) * 100
    
    def block(self, reasons: List[str]):
        """é˜»æ“‹äº¤æ˜“"""
        self.status = "BLOCKED"
        self.blocked_reasons = reasons
        self.can_trade = False
    
    def to_dict(self) -> dict:
        """è½‰æ›ç‚ºå­—å…¸ï¼ˆç”¨æ–¼ä¿å­˜ï¼‰"""
        return {
            # åŸºæœ¬ä¿¡æ¯
            'order_id': self.order_id,
            'mode': self.mode,
            'timestamp': self.timestamp,
            'entry_time': self.entry_time.isoformat(),
            
            # å¸‚å ´æ•¸æ“š
            'entry_price': self.entry_price,
            'actual_entry_price': self.actual_entry_price,
            'market_data': self.market_data,
            
            # æ±ºç­–ä¿¡æ¯
            'direction': self.direction,
            'confidence': self.confidence,
            'risk_level': self.risk_level,
            'signal': self.signal,
            
            # å€‰ä½ä¿¡æ¯
            'capital': self.capital,
            'leverage': self.leverage,
            'size': self.size,
            'position_value': self.position_value,
            'stop_loss_pct': self.stop_loss_pct,
            'take_profit_pct': self.take_profit_pct,
            
            # å¹³å€‰ä¿¡æ¯
            'exit_price': self.exit_price,
            'exit_time': self.exit_time.isoformat() if self.exit_time else None,
            'exit_reason': self.exit_reason,
            'holding_seconds': self.holding_seconds,
            
            # è²»ç”¨
            'entry_fee': self.entry_fee,
            'exit_fee': self.exit_fee if hasattr(self, 'exit_fee') else None,
            'funding_fee': self.funding_fee if hasattr(self, 'funding_fee') else None,
            'total_fees': self.total_fees if hasattr(self, 'total_fees') else None,
            
            # ç›ˆè™§
            'pnl_usdt': self.pnl_usdt,
            'pnl_pct': self.pnl_pct,
            'roi': self.roi,
            
            # ç‹€æ…‹
            'status': self.status,
            'can_trade': self.can_trade,
            'blocked_reasons': self.blocked_reasons
        }


class PaperTradingSystem:
    """ç´™é¢äº¤æ˜“ç³»çµ±"""
    
    def __init__(self, initial_capital: float = 100.0, 
                 decision_interval: int = 15,
                 strategy_config_path: str = "config/trading_strategies.json"):
        self.initial_capital = initial_capital
        self.decision_interval = decision_interval
        
        # è¼‰å…¥ç­–ç•¥ç®¡ç†å™¨
        self.strategy_manager = StrategyManager(strategy_config_path)
        
        # ç²å–æ‰€æœ‰å•Ÿç”¨çš„ç­–ç•¥
        self.active_modes = self.strategy_manager.get_all_modes()
        print(f"âœ… è¼‰å…¥ {len(self.active_modes)} å€‹ç­–ç•¥:")
        for mode_key in self.active_modes:
            info = self.strategy_manager.get_strategy_info(mode_key)
            print(f"   {info['emoji']} {info['name']} - {info['leverage']}x æ§“æ¡¿")
        
        # æŒ‡æ¨™æ¨¡çµ„
        self.obi_calc = OBICalculator(depth_limit=20)
        self.signed_volume = SignedVolumeTracker(window_size=100)
        self.vpin_calc = VPINCalculator(bucket_size=10000, num_buckets=50)
        self.spread_depth = SpreadDepthMonitor(depth_levels=10)
        
        # äº¤æ˜“å¼•æ“
        self.trading_engine = LayeredTradingEngine()
        
        # è¨‚å–®ç°¿ï¼ˆå‹•æ…‹å‰µå»ºï¼Œæ¯ç¨®æ¨¡å¼ç¨ç«‹ï¼‰
        self.orders = {mode: [] for mode in self.active_modes}
        
        # ç•¶å‰æŒå€‰ï¼ˆå‹•æ…‹å‰µå»ºï¼Œæ¯ç¨®æ¨¡å¼ç¨ç«‹ï¼‰
        self.positions = {mode: None for mode in self.active_modes}
        
        # è³‡é‡‘è¿½è¹¤ï¼ˆå‹•æ…‹å‰µå»ºï¼Œæ¯ç¨®æ¨¡å¼ç¨ç«‹ï¼‰
        self.balances = {mode: initial_capital for mode in self.active_modes}
        
        # çµ±è¨ˆ
        self.total_decisions = 0
        self.order_counter = 0
        
        # OBI æ­·å²ï¼ˆç”¨æ–¼è¨ˆç®— velocityï¼‰
        self.obi_history = deque(maxlen=10)
        
        # å¤šæ™‚é–“æ¡†æ¶ OBI æ­·å² (for Mode 13)
        self.obi_5min_history = deque(maxlen=60)    # 300ç§’ / 5ç§’ = 60å€‹æ•¸æ“šé»
        self.obi_15min_history = deque(maxlen=180)  # 900ç§’ / 5ç§’ = 180å€‹æ•¸æ“šé»
        self.obi_30min_history = deque(maxlen=360)  # 1800ç§’ / 5ç§’ = 360å€‹æ•¸æ“šé»
        self.obi_1hour_history = deque(maxlen=720)  # 3600ç§’ / 5ç§’ = 720å€‹æ•¸æ“šé»
        self.obi_4hour_history = deque(maxlen=2880) # 14400ç§’ / 5ç§’ = 2880å€‹æ•¸æ“šé»
        self.obi_8hour_history = deque(maxlen=5760) # 28800ç§’ / 5ç§’ = 5760å€‹æ•¸æ“šé»
        
        # å¸‚å ´ç‹€æ…‹
        self.latest_price = None
        self.orderbook_timestamp = None
        
        # WebSocket
        self.ws = None
        
        # åˆå§‹åŒ–æ¨™è¨˜
        self.is_initialized = False
        
        # é…ç½®ç†±é‡è¼‰ç›£æ§å™¨
        self.config_monitor = ConfigMonitor(
            strategy_config_path, 
            check_interval=3,
            on_reload=self._on_config_reload
        )
        self.last_config_check = time.time()
        
        # å³æ™‚ä¿å­˜æª”æ¡ˆåç¨±ï¼ˆåœ¨é–‹å§‹æ™‚ç¢ºå®šï¼Œé¿å…æ¯æ¬¡éƒ½ç”Ÿæˆæ–°æª”åï¼‰
        self.save_timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        self.json_filename = f"data/paper_trading/paper_trading_{self.save_timestamp}.json"
        self.log_filename = f"data/paper_trading/paper_trading_{self.save_timestamp}.log"
        self.terminal_log_filename = f"data/paper_trading/paper_trading_{self.save_timestamp}_terminal.txt"
        self.visual_report_filename = f"data/paper_trading/paper_trading_{self.save_timestamp}_visual_report.txt"
        
        # ç¢ºä¿ data/paper_trading ç›®éŒ„å­˜åœ¨
        Path("data/paper_trading").mkdir(parents=True, exist_ok=True)
        
        # è¦–è¦ºåŒ–å ±å‘Šè¿½è¹¤æ•¸æ“š
        self.test_start_time = datetime.now()
        self.vpin_history = deque(maxlen=100)  # è¨˜éŒ„æœ€è¿‘ 100 å€‹ VPIN å€¼
        self.last_report_update = 0  # æœ€å¾Œæ›´æ–°å ±å‘Šçš„æ™‚é–“æˆ³
        
        # åˆå§‹åŒ–æª”æ¡ˆ
        self._init_save_file()
        
        # æ‰“é–‹çµ‚ç«¯æ—¥èªŒæª”æ¡ˆï¼ˆè¿½åŠ æ¨¡å¼ï¼Œå³æ™‚å¯«å…¥ï¼‰
        self.terminal_log_file = open(self.terminal_log_filename, 'w', encoding='utf-8', buffering=1)
        
        # è‡ªå®šç¾© print å‡½æ•¸ï¼ˆåŒæ™‚è¼¸å‡ºåˆ°çµ‚ç«¯å’Œæª”æ¡ˆï¼‰
        self.original_print = print
        import builtins
        builtins.print = self._log_print
        
        print("=" * 80)
        print("ï¿½ Task 1.6.1 - Phase C: ç´™é¢äº¤æ˜“ç³»çµ± (Paper Trading System)")
        print("=" * 80)
        print()
        
        # å¸‚å ´æŒ‡æ¨™èªªæ˜
        print("â”€" * 80)
        print("ğŸ“– å¸‚å ´æŒ‡æ¨™èªªæ˜")
        print("â”€" * 80)
        print("ğŸ“Š OBI (Order Book Imbalance)     è¨‚å–®ç°¿å¤±è¡¡åº¦ [-1, 1]")
        print("   â€¢ æ­£å€¼ = è²·ç›¤å¼·å‹¢ | è² å€¼ = è³£ç›¤å¼·å‹¢ | 0 = å¹³è¡¡")
        print("   â€¢ è¶Šæ¥è¿‘ Â±1 ä»£è¡¨å¤±è¡¡è¶Šåš´é‡")
        print()
        print("âš¡ OBI Velocity                    OBI è®ŠåŒ–ç‡ (é€Ÿåº¦)")
        print("   â€¢ æ­£å€¼ = è²·ç›¤å¢å¼· | è² å€¼ = è³£ç›¤å¢å¼·")
        print("   â€¢ çµ•å°å€¼è¶Šå¤§ä»£è¡¨è®ŠåŒ–è¶Šå¿«")
        print()
        print("ğŸ“ˆ Signed Volume                   æ·¨æˆäº¤é‡ (è²·-è³£)")
        print("   â€¢ æ­£å€¼ = ä¸»å‹•è²·å–®å¤š | è² å€¼ = ä¸»å‹•è³£å–®å¤š")
        print("   â€¢ åæ˜ çŸ­æœŸè²·è³£å£“åŠ›")
        print()
        print("â˜ ï¸  VPIN (Volume-Synchronized PIN)  æ¯’æ€§æŒ‡æ¨™ [0, 1]")
        print("   â€¢ 0 = ä½é¢¨éšª | 1 = é«˜é¢¨éšª")
        print("   â€¢ >0.5 è¡¨ç¤ºçŸ¥æƒ…äº¤æ˜“è€…æ´»èºï¼Œéœ€è¬¹æ…")
        print()
        print("ğŸ’¹ Spread                          è²·è³£åƒ¹å·® (bps)")
        print("   â€¢ è¶Šå° = æµå‹•æ€§è¶Šå¥½ | è¶Šå¤§ = æµå‹•æ€§å·®")
        print()
        print("ğŸŠ Depth                           è¨‚å–®ç°¿æ·±åº¦ (BTC)")
        print("   â€¢ å‰5æª”è²·è³£å–®ç¸½é‡ï¼Œåæ˜ å¸‚å ´æ‰¿æ¥åŠ›")
        print("â”€" * 80)
        print()
        
        # åœ–ç¤ºèªªæ˜
        print("â”€" * 80)
        print("ğŸ¨ åœ–ç¤ºèªªæ˜")
        print("â”€" * 80)
        print("äº¤æ˜“æ–¹å‘:  ğŸ“ˆ LONG (åšå¤š)  |  ğŸ“‰ SHORT (åšç©º)  |  âš–ï¸  NEUTRAL (ä¸­ç«‹)")
        print("é¢¨éšªç­‰ç´š:  ğŸŸ¢ SAFE (å®‰å…¨)  |  ğŸŸ¡ WARNING (è­¦å‘Š)  |  ğŸ”´ CRITICAL (åš´é‡)")
        print("æŒå€‰ç‹€æ…‹:  ğŸ¦ ç©ºå€‰  |  ğŸ“Š æŒå€‰ä¸­")
        print("é–‹å€‰:      ğŸš€ é–‹å€‰  |  ğŸ”” å¹³å€‰")
        print("å¹³å€‰åŸå› :  ğŸ¯ TAKE_PROFIT (æ­¢ç›ˆ)  |  ğŸ›‘ STOP_LOSS (æ­¢æ)  |  ğŸ”„ REVERSE_SIGNAL (åå‘)")
        print("â”€" * 80)
        print()
        
        # é¢¨æ§æ¨¡å¼å°æ¯”
        print("ğŸ¯ é¢¨æ§æ¨¡å¼å°æ¯”:")
        print("   Mode 0: âŒ ç„¡é¢¨æ§ï¼ˆæ‰€æœ‰ä¿¡è™Ÿéƒ½äº¤æ˜“ï¼‰")
        print("   Mode 1: ğŸŸ¡ åƒ… VPIN é¢¨æ§")
        print("   Mode 2: ğŸ”µ åƒ…æµå‹•æ€§é¢¨æ§ï¼ˆSpread/Depthï¼‰")
        print("   Mode 3: ğŸŸ¢ å®Œæ•´é¢¨æ§ï¼ˆæ‰€æœ‰æŒ‡æ¨™ï¼‰")
        print()
        
        # é…ç½®ä¿¡æ¯
        print("â±ï¸  æ¸¬è©¦é…ç½®:")
        print("   ğŸ’¹ äº¤æ˜“å°: BTCUSDT")
        print(f"   âš¡ æ±ºç­–æ¨¡å¼: å‹•æ…‹è§¸ç™¼ (æœ€å¿«5ç§’ / æœ€æ…¢{decision_interval}ç§’)")
        print("   ğŸ¯ è§¸ç™¼æ¢ä»¶:")
        print("      â€¢ å¼·çƒˆä¿¡è™Ÿ: |OBI| > 0.6")
        print("      â€¢ å¿«é€Ÿè®ŠåŒ–: |Î”OBI| > 0.3")
        print("      â€¢ æ–¹å‘åè½‰: OBIè·¨è¶Š0è»¸")
        print()
        print("ğŸ’° è³‡é‡‘é…ç½®:")
        print(f"   ğŸ’µ åˆå§‹æœ¬é‡‘: {initial_capital} USDT (æ¯æ¨¡å¼)")
        print(f"   ğŸ“Š {len(self.active_modes)} å€‹ç­–ç•¥å·²è¼‰å…¥ (æ§“æ¡¿å·²åœ¨ä¸Šæ–¹é¡¯ç¤º)")
        print("   ğŸ“ å€‰ä½ç­–ç•¥: ğŸ¢ ä¿å®ˆ 30% | ğŸš¶ ä¸­ç­‰ 50% | ğŸƒ æ¿€é€² 80%")
        print()
        print("ğŸ’¸ è²»ç‡è¨­å®š:")
        print("   âœ… Maker æ‰‹çºŒè²»: 0.02%")
        print("   ğŸ’³ Taker æ‰‹çºŒè²»: 0.05%")
        print("   ğŸ’° è³‡é‡‘è²»ç‡: 0.003%/å°æ™‚")
        print()
        print("ğŸ¯ é¢¨æ§è¨­å®š:")
        print("   ğŸŸ¢ å®‰å…¨æ¨¡å¼: æ§“æ¡¿ 5x | æ­¢æ 5% | æ­¢ç›ˆ 8%")
        print("   ğŸŸ¡ è­¦å‘Šæ¨¡å¼: æ§“æ¡¿ 2x | æ­¢æ 8% | æ­¢ç›ˆ 12%")
        print("   ğŸ”´ å±éšªæ¨¡å¼: æ§“æ¡¿ 1x | æ­¢æ 10% | æ­¢ç›ˆ 15%")
        print()
        print("=" * 80)
        print()
    
    async def initialize_orderbook(self):
        """ä½¿ç”¨ REST API åˆå§‹åŒ–è¨‚å–®ç°¿æ•¸æ“š"""
        if self.is_initialized:
            return
            
        print("ğŸ“¥ åˆå§‹åŒ–è¨‚å–®ç°¿æ•¸æ“š...")
        
        try:
            # ä½¿ç”¨ Binance REST API ç²å–åˆå§‹è¨‚å–®ç°¿
            url = "https://fapi.binance.com/fapi/v1/depth?symbol=BTCUSDT&limit=20"
            
            with urlopen(url, timeout=5) as response:
                orderbook = json.loads(response.read().decode())
                
                # è½‰æ›ç‚ºæµ®é»æ•¸
                bids = [[float(p), float(q)] for p, q in orderbook['bids']]
                asks = [[float(p), float(q)] for p, q in orderbook['asks']]
                
                # åˆå§‹åŒ–æ‰€æœ‰æŒ‡æ¨™
                self.obi_calc.update_orderbook(bids, asks)
                self.spread_depth.update(bids, asks)
                
                # æ›´æ–°æœ€æ–°åƒ¹æ ¼
                self.latest_price = (bids[0][0] + asks[0][0]) / 2
                
                print(f"   âœ… è¨‚å–®ç°¿å·²åˆå§‹åŒ–")
                print(f"   æœ€ä½³è²·åƒ¹: {bids[0][0]:,.2f}")
                print(f"   æœ€ä½³è³£åƒ¹: {asks[0][0]:,.2f}")
                print(f"   ç•¶å‰åƒ¹æ ¼: ${self.latest_price:,.2f}")
                print(f"   è²·å–®é‡ (20æª”): {sum(q for _, q in bids):.4f} BTC")
                print(f"   è³£å–®é‡ (20æª”): {sum(q for _, q in asks):.4f} BTC")
                
                # è¨ˆç®—åˆå§‹ OBI
                obi_data = self.obi_calc.get_current_obi()
                if obi_data:
                    print(f"   åˆå§‹ OBI: {obi_data['obi']:+.4f}")
                print()
                
                self.is_initialized = True
                
        except Exception as e:
            print(f"   âš ï¸ åˆå§‹åŒ–å¤±æ•—: {e}")
            print("   å°‡ä½¿ç”¨ WebSocket æ•¸æ“š")
    
    async def connect_websocket(self):
        """é€£æ¥ Binance WebSocket"""
        streams = [
            "btcusdt@bookTicker",  # æœ€å„ªè²·è³£åƒ¹
            "btcusdt@depth20@100ms",  # è¨‚å–®ç°¿æ·±åº¦
            "btcusdt@aggTrade"  # èšåˆäº¤æ˜“
        ]
        url = f"wss://fstream.binance.com/stream?streams={'/'.join(streams)}"
        
        print("ğŸ”Œ é€£æ¥ Binance WebSocket...")
        self.ws = await websockets.connect(url)
        print("âœ… WebSocket å·²é€£æ¥")
        print()
    
    async def handle_message(self, msg: dict):
        """è™•ç† WebSocket æ¶ˆæ¯"""
        stream = msg.get('stream', '')
        data = msg.get('data', {})
        
        if 'bookTicker' in stream:
            # æœ€å„ªè²·è³£åƒ¹
            self.latest_price = (float(data['b']) + float(data['a'])) / 2
            self.orderbook_timestamp = data['E']
            
        elif 'depth' in stream:
            # è¨‚å–®ç°¿æ·±åº¦
            bids = [[float(p), float(q)] for p, q in data['b']]
            asks = [[float(p), float(q)] for p, q in data['a']]
            
            # æ›´æ–° OBI
            self.obi_calc.update_orderbook(bids, asks)
            
            # æ›´æ–° Spread/Depth
            self.spread_depth.update(bids, asks)
            
        elif 'aggTrade' in stream:
            # äº¤æ˜“æ•¸æ“š
            # æ›´æ–° Signed Volume
            self.signed_volume.add_trade(data)
            
            # æ›´æ–° VPIN
            self.vpin_calc.process_trade(data)
    
    async def make_decision(self) -> dict:
        """ç”Ÿæˆäº¤æ˜“æ±ºç­–"""
        # æ­¥é©Ÿ 1: ç²å– OBI
        print("   ğŸ” [1/6] è¨ˆç®— OBI (è¨‚å–®ç°¿å¤±è¡¡)...", end='', flush=True)
        await asyncio.sleep(0.05)
        obi_data = self.obi_calc.get_current_obi()
        if obi_data is None:
            print(" âŒ æ•¸æ“šä¸è¶³")
            return None
        
        current_obi = obi_data['obi']
        print(f" âœ… OBI = {current_obi:+.4f}")
        
        # è¨ˆç®— OBI velocity
        self.obi_history.append(current_obi)
        
        # æ›´æ–°å¤šæ™‚é–“æ¡†æ¶ OBI æ­·å² (for Mode 13)
        self.obi_5min_history.append(current_obi)
        self.obi_15min_history.append(current_obi)
        self.obi_30min_history.append(current_obi)
        self.obi_1hour_history.append(current_obi)
        self.obi_4hour_history.append(current_obi)
        self.obi_8hour_history.append(current_obi)
        
        obi_velocity = 0.0
        if len(self.obi_history) >= 2:
            obi_velocity = self.obi_history[-1] - self.obi_history[-2]
        
        # æ­¥é©Ÿ 2: ç²å–è¨‚å–®ç°¿
        print("   ğŸ” [2/6] åˆ†æè¨‚å–®ç°¿æ·±åº¦...", end='', flush=True)
        await asyncio.sleep(0.05)
        bids = self.obi_calc.orderbook.get('bids', [])
        asks = self.obi_calc.orderbook.get('asks', [])
        
        if not bids or not asks:
            print(" âŒ è¨‚å–®ç°¿ä¸å®Œæ•´")
            return None
        print(f" âœ… Bids/Asks = {len(bids)}/{len(asks)} æª”")
        
        # æ­¥é©Ÿ 3: è¨ˆç®— Signed Volume
        print("   ğŸ” [3/6] è¨ˆç®— Signed Volume (è²·è³£å£“åŠ›)...", end='', flush=True)
        await asyncio.sleep(0.05)
        signed_vol = self.signed_volume.calculate_signed_volume()
        volume_imbalance = self.signed_volume.calculate_volume_imbalance()
        print(f" âœ… SV = {signed_vol:+.2f}")
        
        # æ­¥é©Ÿ 4: è¨ˆç®— VPIN
        print("   ğŸ” [4/6] è¨ˆç®— VPIN (æ¯’æ€§æŒ‡æ¨™)...", end='', flush=True)
        await asyncio.sleep(0.05)
        vpin = self.vpin_calc.calculate_vpin()
        vpin_display = vpin if vpin is not None else 0.3
        print(f" âœ… VPIN = {vpin_display:.3f}")
        
        # ğŸ†• è¨˜éŒ„ VPIN æ­·å²ï¼ˆç”¨æ–¼è¦–è¦ºåŒ–å ±å‘Šï¼‰
        if vpin is not None:
            current_time = int(time.time() * 1000)
            self.vpin_history.append((current_time, vpin))
        
        # æ­¥é©Ÿ 5: è¨ˆç®— Spread & Depth
        print("   ğŸ” [5/6] è¨ˆç®— Spread & Depth (æµå‹•æ€§)...", end='', flush=True)
        await asyncio.sleep(0.05)
        spread_data = self.spread_depth.calculate_spread(bids, asks)
        depth_data = self.spread_depth.calculate_depth(bids, asks)
        
        spread_bps = spread_data.get('spread_bps', 5.0) if spread_data else 5.0
        total_depth = depth_data.get('total_depth', 5.0) if depth_data else 5.0
        print(f" âœ… Spread = {spread_bps:.2f} bps, Depth = {total_depth:.2f} BTC")
        
        # ä½¿ç”¨é»˜èªå€¼é¿å…æ•¸æ“šæœªå°±ç·’
        if vpin is None:
            vpin = 0.3
        if signed_vol is None:
            signed_vol = 0.0
        if not spread_data:
            spread_data = {'spread_bps': 5.0}
        if not depth_data:
            depth_data = {'total_depth': 5.0, 'depth_imbalance': 0.0}
        
        # æ•´åˆå¸‚å ´æ•¸æ“š
        market_data = {
            'obi': float(current_obi),
            'obi_velocity': float(obi_velocity),
            'signed_volume': float(signed_vol),
            'volume_imbalance': float(volume_imbalance.get('imbalance', 0.0)),
            'vpin': float(vpin),
            'spread_bps': float(spread_data.get('spread_bps', 5.0)),
            'total_depth': float(depth_data.get('total_depth', 5.0)),
            'depth_imbalance': float(depth_data.get('depth_imbalance', 0.0)),
            'price': self.latest_price,
            'timestamp': self.orderbook_timestamp,
            # å¤šæ™‚é–“æ¡†æ¶ OBI (for Mode 13)
            'obi_5min': self._calculate_timeframe_obi(self.obi_5min_history),
            'obi_15min': self._calculate_timeframe_obi(self.obi_15min_history),
            'obi_30min': self._calculate_timeframe_obi(self.obi_30min_history),
            'obi_1hour': self._calculate_timeframe_obi(self.obi_1hour_history),
            'obi_4hour': self._calculate_timeframe_obi(self.obi_4hour_history),
            'obi_8hour': self._calculate_timeframe_obi(self.obi_8hour_history)
        }
        
        # è¨ˆç®—é¢¨éšªç­‰ç´š
        risk_level = self._determine_risk_level(market_data)
        
        # æ­¥é©Ÿ 6: ç”Ÿæˆäº¤æ˜“æ±ºç­–
        print("   ğŸ” [6/6] ç”Ÿæˆäº¤æ˜“æ±ºç­– (åˆ†å±¤å¼•æ“)...", end='', flush=True)
        await asyncio.sleep(0.05)
        decision = self.trading_engine.process_market_data(market_data)
        decision['risk_level'] = risk_level
        decision['market_data'] = market_data
        print(f" âœ… ä¿¡è™Ÿ = {decision['signal']['direction']}")
        print()
        
        return decision
    
    def _calculate_timeframe_obi(self, obi_history: deque) -> float:
        """è¨ˆç®—æŒ‡å®šæ™‚é–“æ¡†æ¶çš„ OBI å¹³å‡å€¼"""
        if len(obi_history) == 0:
            return 0.0
        return float(np.mean(obi_history))
    
    def _on_config_reload(self, new_config: dict):
        """é…ç½®é‡è¼‰å›èª¿å‡½æ•¸"""
        print("ğŸ”„ æ­£åœ¨æ‡‰ç”¨æ–°é…ç½®...")
        
        # é‡æ–°è¼‰å…¥ç­–ç•¥ç®¡ç†å™¨
        self.strategy_manager = StrategyManager(self.config_monitor.config_path)
        
        # æ›´æ–°æ´»èºç­–ç•¥åˆ—è¡¨
        old_modes = set(self.active_modes)
        new_modes = set(self.strategy_manager.get_all_modes())
        
        # æ–°å¢çš„ç­–ç•¥
        added_modes = new_modes - old_modes
        for mode in added_modes:
            self.orders[mode] = []
            self.positions[mode] = None
            self.balances[mode] = self.initial_capital
            print(f"   âœ¨ æ–°å¢ç­–ç•¥: {mode}")
        
        # ç§»é™¤çš„ç­–ç•¥ï¼ˆä¿ç•™æ•¸æ“šï¼Œä½†ä¸å†äº¤æ˜“ï¼‰
        removed_modes = old_modes - new_modes
        for mode in removed_modes:
            print(f"   ğŸ—‘ï¸  ç§»é™¤ç­–ç•¥: {mode}")
        
        # æ›´æ–°æ´»èºæ¨¡å¼åˆ—è¡¨
        self.active_modes = list(new_modes)
        
        print(f"âœ… é…ç½®å·²æ‡‰ç”¨ï¼Œç•¶å‰å…± {len(self.active_modes)} å€‹ç­–ç•¥")
    
    def _determine_risk_level(self, market_data: dict) -> str:
        """æ ¹æ“šæŒ‡æ¨™è¨ˆç®—é¢¨éšªç­‰ç´š"""
        vpin = market_data.get('vpin', 0.3)
        spread_bps = market_data.get('spread_bps', 5.0)
        total_depth = market_data.get('total_depth', 5.0)
        
        # é¢¨éšªè©•åˆ†
        risk_score = 0
        
        # VPIN é¢¨éšª
        if vpin > 0.7:
            risk_score += 3
        elif vpin > 0.5:
            risk_score += 2
        elif vpin > 0.3:
            risk_score += 1
        
        # Spread é¢¨éšª
        if spread_bps > 15:
            risk_score += 3
        elif spread_bps > 10:
            risk_score += 2
        elif spread_bps > 5:
            risk_score += 1
        
        # Depth é¢¨éšª
        if total_depth < 2:
            risk_score += 3
        elif total_depth < 3:
            risk_score += 2
        elif total_depth < 5:
            risk_score += 1
        
        # åˆ¤å®šé¢¨éšªç­‰ç´š
        if risk_score >= 7:
            return 'CRITICAL'
        elif risk_score >= 5:
            return 'DANGER'
        elif risk_score >= 3:
            return 'WARNING'
        else:
            return 'SAFE'
    
    def apply_risk_control(self, decision: dict, mode: str) -> Tuple[bool, List[str]]:
        """æ‡‰ç”¨é¢¨æ§è¦å‰‡ï¼ˆä½¿ç”¨ç­–ç•¥ç®¡ç†å™¨ï¼‰"""
        market_data = decision.get('market_data', {})
        signal = decision.get('signal', {})
        
        # ä½¿ç”¨ç­–ç•¥ç®¡ç†å™¨çš„é¢¨æ§æª¢æŸ¥
        can_trade, blocked_reasons = self.strategy_manager.apply_risk_control(
            mode, market_data, signal
        )
        
        return can_trade, blocked_reasons
    
    def print_trade_timeline(self, decision: dict, timestamp: str):
        """é¡¯ç¤ºå³æ™‚äº¤æ˜“æ™‚é–“è»¸è¨˜éŒ„"""
        signal = decision['signal']
        market_data = decision.get('market_data', {})
        obi = market_data.get('obi', 0)
        
        # ç²å–ä¿¡è™Ÿé¡å‹
        signal_map = {
            'LONG': 'STRONG_BUY' if abs(obi) > 0.5 else 'BUY',
            'SHORT': 'STRONG_SELL' if abs(obi) > 0.5 else 'SELL',
            'NEUTRAL': 'NEUTRAL'
        }
        signal_type = signal_map.get(signal['direction'], 'NEUTRAL')
        
        # é¡¯ç¤ºæ¯å€‹æ¨¡å¼çš„ç‹€æ…‹
        print()
        print("ï¿½ è³‡é‡‘ç«¶è³½æ’è¡Œæ¦œ:")
        print("-" * 80)
        
        # è¨ˆç®—æ¯å€‹æ¨¡å¼çš„ç¸½è³‡ç”¢ï¼ˆé¤˜é¡ + æœªå¯¦ç¾ç›ˆè™§ï¼‰
        mode_balances = []
        for mode in self.active_modes:
            # å¾ç­–ç•¥ç®¡ç†å™¨ç²å–ç­–ç•¥ä¿¡æ¯
            strategy_info = self.strategy_manager.get_strategy_info(mode)
            mode_label = f"{strategy_info['emoji']} {strategy_info['name'][:8]}"  # æˆªçŸ­åç¨±
            
            balance = self.balances[mode]
            position = self.positions[mode]
            
            # åŠ ä¸Šæœªå¯¦ç¾ç›ˆè™§
            total_equity = balance
            unrealized_pnl_usdt = 0
            if position:
                if position.direction == "LONG":
                    unrealized_pnl = ((self.latest_price - position.actual_entry_price) / 
                                     position.actual_entry_price) * 100 * position.leverage
                else:
                    unrealized_pnl = ((position.actual_entry_price - self.latest_price) / 
                                     position.actual_entry_price) * 100 * position.leverage
                unrealized_pnl_usdt = (unrealized_pnl / 100) * position.capital
                total_equity += unrealized_pnl_usdt
            
            mode_balances.append((mode, mode_label, balance, unrealized_pnl_usdt, total_equity))
        
        # ====== æ’è¡Œæ¦œ #1: å·²å¯¦ç¾æç›Š ======
        print("ğŸ’° [å·²å¯¦ç¾æç›Š] æ’è¡Œæ¦œ (å·²å¹³å€‰ç²åˆ©):")
        print("-" * 80)
        
        # æŒ‰å·²å¯¦ç¾é¤˜é¡æ’åº
        realized_ranking = sorted(mode_balances, key=lambda x: x[2], reverse=True)
        rank_emojis = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'] + [f'{i:2d}.' for i in range(4, len(realized_ranking)+1)]
        
        for i, (mode, label, balance, unrealized, total) in enumerate(realized_ranking):
            if i >= len(rank_emojis):
                break
            rank = rank_emojis[i]
            realized_pnl = balance - self.initial_capital
            realized_pct = (realized_pnl / self.initial_capital) * 100
            pnl_emoji = "ğŸŸ¢" if realized_pct >= 0 else "ğŸ”´"
            leverage = self.strategy_manager.get_leverage(mode)
            
            print(f"{rank} {label} | ğŸ’° {balance:.2f} USDT ({realized_pnl:+.2f}) | {pnl_emoji} {realized_pct:+.2f}% | âš¡ {leverage}xæ§“æ¡¿")
        
        print("-" * 80)
        
        # ====== æ’è¡Œæ¦œ #2: æœªå¯¦ç¾æç›Š ======
        print("ğŸ“Š [æœªå¯¦ç¾æç›Š] æ’è¡Œæ¦œ (æŒå€‰ä¸­æµ®å‹•ç›ˆè™§):")
        print("-" * 80)
        
        # æŒ‰æœªå¯¦ç¾ç›ˆè™§æ’åº
        unrealized_ranking = sorted(mode_balances, key=lambda x: x[3], reverse=True)
        
        for i, (mode, label, balance, unrealized, total) in enumerate(unrealized_ranking):
            if i >= len(rank_emojis):
                break
            rank = rank_emojis[i]
            
            if unrealized != 0:
                unrealized_pct = (unrealized / self.initial_capital) * 100
                pnl_emoji = "ğŸŸ¢" if unrealized >= 0 else "ğŸ”´"
                leverage = self.strategy_manager.get_leverage(mode)
                print(f"{rank} {label} | ï¿½ {unrealized:+.2f} USDT | {pnl_emoji} {unrealized_pct:+.2f}% | âš¡ {leverage}xæ§“æ¡¿")
            else:
                leverage = self.strategy_manager.get_leverage(mode)
                print(f"{rank} {label} | ï¿½ ç„¡æŒå€‰ | âšª 0.00% | âš¡ {leverage}xæ§“æ¡¿")
        
        print("-" * 80)
        
        print()
        print("ï¿½ğŸ“‹ å³æ™‚äº¤æ˜“è¨˜éŒ„:")
        print("-" * 80)
        
        for mode in self.active_modes:
            strategy_info = self.strategy_manager.get_strategy_info(mode)
            mode_label = f"{strategy_info['emoji']} {strategy_info['name'][:8]}"
            
            position = self.positions[mode]
            
            if position:
                # æœ‰æŒå€‰
                direction_emoji = "ğŸ“ˆ" if position.direction == "LONG" else "ğŸ“‰"
                
                # è¨ˆç®—æœªå¯¦ç¾ç›ˆè™§
                if position.direction == "LONG":
                    unrealized_pnl = ((self.latest_price - position.actual_entry_price) / 
                                     position.actual_entry_price) * 100 * position.leverage
                else:
                    unrealized_pnl = ((position.actual_entry_price - self.latest_price) / 
                                     position.actual_entry_price) * 100 * position.leverage
                
                pnl_emoji = "ğŸŸ¢" if unrealized_pnl > 0 else "ğŸ”´"
                status = f"æŒæœ‰ {position.direction}"
                
                print(f"{timestamp} | {obi:+7.4f} | {signal_type:<12} | {mode_label} | {direction_emoji} {status:<8} | {pnl_emoji} {unrealized_pnl:+.2f}%")
            else:
                # ç©ºå€‰
                status = "ç©ºå€‰"
                action = "è§€æœ›"
                print(f"{timestamp} | {obi:+7.4f} | {signal_type:<12} | {mode_label} | ğŸ¦ {status:<8} | {action}")
        
        print("-" * 80)
    
    def create_orders(self, decision: dict):
        """ç‚ºæ¯ç¨®æ¨¡å¼å‰µå»ºè¨‚å–®"""
        if decision is None:
            return
        
        signal = decision['signal']
        
        # ç‚ºæ¯ç¨®å•Ÿç”¨çš„ç­–ç•¥å‰µå»ºè¨‚å–®
        for mode in self.active_modes:
            # è·³éå·²æœ‰æŒå€‰çš„æ¨¡å¼
            if self.positions[mode] is not None:
                continue
            
            # ç²å–ç­–ç•¥ä¿¡æ¯
            strategy_info = self.strategy_manager.get_strategy_info(mode)
            
            # Mode 0 å’Œ Mode 0' å¼·åˆ¶äº¤æ˜“æ‰€æœ‰ä¿¡è™Ÿï¼ˆåŒ…æ‹¬ NEUTRALï¼‰
            # å…¶ä»–æ¨¡å¼åªå° LONG/SHORT å‰µå»ºè¨‚å–®
            if mode in ['mode_0_baseline', 'mode_0_reverse']:
                # å¦‚æœæ˜¯ NEUTRALï¼Œæ ¹æ“š OBI æ±ºå®šæ–¹å‘
                if signal['direction'] == 'NEUTRAL':
                    market_data = decision.get('market_data', {})
                    obi = market_data.get('obi', 0)
                    
                    if obi > 0:
                        forced_direction = 'LONG'
                    elif obi < 0:
                        forced_direction = 'SHORT'
                    else:
                        signed_vol = market_data.get('signed_volume', 0)
                        forced_direction = 'LONG' if signed_vol >= 0 else 'SHORT'
                    
                    forced_signal = signal.copy()
                    forced_signal['direction'] = forced_direction
                    forced_signal['forced'] = True
                    
                    # åå‘äº¤æ˜“: ç¿»è½‰ä¿¡è™Ÿ
                    if mode == 'mode_0_reverse':
                        forced_signal['direction'] = 'SHORT' if forced_direction == 'LONG' else 'LONG'
                        forced_signal['reversed'] = True
                        print(f"  [{strategy_info['emoji']} {strategy_info['name']}] ğŸ”„ åå‘å¼·åˆ¶: NEUTRAL â†’ {forced_direction} â†’ {forced_signal['direction']} (OBI={obi:+.4f})")
                    else:
                        print(f"  [{strategy_info['emoji']} {strategy_info['name']}] âš ï¸  å¼·åˆ¶äº¤æ˜“: NEUTRAL â†’ {forced_direction} (OBI={obi:+.4f})")
                else:
                    forced_signal = signal.copy()
                    # åå‘äº¤æ˜“: ç¿»è½‰ä¿¡è™Ÿ
                    if mode == 'mode_0_reverse':
                        forced_signal['direction'] = 'SHORT' if signal['direction'] == 'LONG' else 'LONG'
                        forced_signal['reversed'] = True
            else:
                # å…¶ä»–æ¨¡å¼ï¼šåªå° LONG/SHORT å‰µå»ºè¨‚å–®
                if signal['direction'] == 'NEUTRAL':
                    continue
                forced_signal = signal
            
            # å‰µå»ºè¨‚å–®ï¼ˆä½¿ç”¨ç­–ç•¥ç®¡ç†å™¨çš„åƒæ•¸ï¼‰
            order = SimulatedOrder(
                order_id=self.order_counter,
                timestamp=self.orderbook_timestamp,
                price=self.latest_price,
                signal=forced_signal,
                market_data=decision.get('market_data', {}),
                mode=mode,
                capital=self.balances[mode],
                leverage=strategy_info['leverage']  # ä½¿ç”¨ç­–ç•¥é…ç½®çš„æ§“æ¡¿
            )
            self.order_counter += 1
            
            # æ‡‰ç”¨é¢¨æ§
            can_trade, blocked_reasons = self.apply_risk_control(decision, mode)
            
            if can_trade:
                # é–‹å€‰
                self.positions[mode] = order
                order.status = "OPEN"
                
                direction_emoji = "ğŸ“ˆ" if order.direction == "LONG" else "ğŸ“‰"
                leverage_emoji = "ğŸ¢" if order.leverage <= 2 else ("ğŸš¶" if order.leverage <= 5 else "ğŸƒ")
                
                # å³æ™‚äº¤æ˜“è¨Šæ¯ - å¢å¼·è¦–è¦ºæ•ˆæœ
                print()
                print()
                
                # æ ¹æ“šæ–¹å‘é¸æ“‡é¡è‰²å’Œåœ–ç¤º
                if order.direction == "LONG":
                    direction_emoji = "ğŸ“ˆ"
                    direction_text = "åšå¤š LONG"
                    border_char = "ğŸŸ¢"
                else:
                    direction_emoji = "ğŸ“‰"
                    direction_text = "åšç©º SHORT"
                    border_char = "ğŸ”´"
                
                # è¨ˆç®—é è¨ˆæŒæœ‰æ™‚é–“ï¼ˆåŸºæ–¼ç­–ç•¥ï¼‰
                if mode == 'mode_13_adaptive':
                    expected_hold = "æœ€é•· 8å°æ™‚"
                elif mode == 'mode_14_dynamic_leverage':
                    expected_hold = "å‹•æ…‹èª¿æ•´"
                elif 'baseline' in mode or 'reverse' in mode:
                    expected_hold = "å¿«é€Ÿé€²å‡º (<1åˆ†é˜)"
                else:
                    expected_hold = "æœ€é•· 2å°æ™‚"
                
                # ç²å–ç•¶å‰æ™‚é–“
                current_time = datetime.now().strftime('%H:%M:%S')
                
                print(f"{border_char * 40}")
                print(f"{'':^80}")
                print(f"{direction_emoji * 3}  {direction_text}  {direction_emoji * 3}".center(80))
                print(f"{'':^80}")
                print(f"{border_char * 40}")
                print()
                print(f"   â° é–‹å€‰æ™‚é–“: {current_time}")
                print(f"   ğŸ¯ ç­–ç•¥æ¨¡å¼: {strategy_info['emoji']} {strategy_info['name']}")
                print(f"   ğŸ’° é€²å ´åƒ¹æ ¼: {order.actual_entry_price:.2f} USDT")
                market_data = decision.get('market_data', {})
                print(f"   ğŸ“Š é€²å ´ OBI: {market_data.get('obi', 0):+.4f}")
                btc_amount = order.position_value / order.actual_entry_price
                print(f"   ğŸª™ å€‰ä½å¤§å°: {btc_amount:.4f} BTC")
                print()
                print(f"   {leverage_emoji} æ§“æ¡¿å€æ•¸: {order.leverage}x")
                print(f"   ğŸ“ å€‰ä½æ¯”ä¾‹: {order.size*100:.0f}%")
                print(f"   ï¿½ å€‰ä½åƒ¹å€¼: ${order.position_value:.2f} USDT")
                print(f"   â±ï¸  é è¨ˆæŒæœ‰: {expected_hold}")
                print()
                print(f"{border_char * 40}")
                print()
            else:
                # é˜»æ“‹
                order.block(blocked_reasons)
                
                print(f"  [{strategy_info['emoji']} {strategy_info['name']}] âŒ é˜»æ“‹äº¤æ˜“")
                print(f"         åŸå› : {', '.join(blocked_reasons)}")
            
            self.orders[mode].append(order)
    
    def check_exits(self, current_decision: dict):
        """æª¢æŸ¥æ‰€æœ‰æŒå€‰æ˜¯å¦æ‡‰è©²å¹³å€‰"""
        for mode, position in self.positions.items():
            if position is None:
                continue
            
            # ç²å–ç­–ç•¥ä¿¡æ¯
            strategy_info = self.strategy_manager.get_strategy_info(mode)
            
            # ç²å–ç•¶å‰å¸‚å ´æ•¸æ“š
            current_market_data = current_decision.get('market_data', {})
            current_obi = current_market_data.get('obi', 0)
            
            # æª¢æŸ¥å¹³å€‰æ¢ä»¶ï¼ˆæ·»åŠ  market_data åƒæ•¸ï¼‰
            exit_reason = position.check_exit(
                current_price=self.latest_price,
                current_signal=current_decision['signal'],
                current_obi=current_obi,
                market_data=current_market_data
            )
            
            if exit_reason:
                # å¹³å€‰
                position.close(
                    exit_price=self.latest_price,
                    reason=exit_reason,
                    timestamp=self.orderbook_timestamp
                )
                
                # æ›´æ–°é¤˜é¡
                self.balances[mode] += position.pnl_usdt
                
                # å³æ™‚å¹³å€‰è¨Šæ¯ - å¢å¼·è¦–è¦ºæ•ˆæœ
                direction_emoji = "ğŸ“ˆ" if position.direction == "LONG" else "ğŸ“‰"
                roi_emoji = "ğŸŸ¢" if position.roi > 0 else "ğŸ”´"
                
                exit_reason_emoji = {
                    'TAKE_PROFIT': 'ğŸ¯',
                    'STOP_LOSS': 'ğŸ›‘',
                    'REVERSE_SIGNAL': 'ğŸ”„',
                    'TIME_LIMIT': 'â°',
                    'TRAILING_STOP': 'ğŸ“‰',
                    'TIME_STOP': 'â±ï¸',
                    'VPIN_SPIKE': 'â˜ ï¸'  # æ–°å¢ï¼šVPIN çªç„¶é£†å‡
                }.get(exit_reason, 'ğŸ””')
                
                # æ ¹æ“šç›ˆè™§é¸æ“‡é‚Šæ¡†
                if position.roi > 0:
                    border_char = "ğŸŸ¢"
                    result_text = "ç²åˆ©å¹³å€‰"
                elif position.roi < 0:
                    border_char = "ğŸ”´"
                    result_text = "è™§æå¹³å€‰"
                else:
                    border_char = "âšª"
                    result_text = "å¹³å€‰"
                
                # æ ¼å¼åŒ–æŒæœ‰æ™‚é–“
                hold_seconds = position.holding_seconds
                if hold_seconds < 60:
                    hold_time_str = f"{hold_seconds:.1f} ç§’"
                elif hold_seconds < 3600:
                    hold_time_str = f"{hold_seconds/60:.1f} åˆ†é˜"
                else:
                    hold_time_str = f"{hold_seconds/3600:.2f} å°æ™‚"
                
                # ç²å–ç•¶å‰æ™‚é–“
                current_time = datetime.now().strftime('%H:%M:%S')
                
                print()
                print()
                print(f"{border_char * 40}")
                print(f"{'':^80}")
                print(f"{exit_reason_emoji * 3}  {result_text}  {exit_reason_emoji * 3}".center(80))
                print(f"{'':^80}")
                print(f"{border_char * 40}")
                print()
                print(f"   â° å¹³å€‰æ™‚é–“: {current_time}")
                print(f"   ğŸ¯ ç­–ç•¥æ¨¡å¼: {strategy_info['emoji']} {strategy_info['name']}")
                print(f"   {direction_emoji} æ–¹å‘: {position.direction}")
                print()
                print(f"   ğŸ’° é€²å ´åƒ¹æ ¼: {position.actual_entry_price:.2f} USDT")
                print(f"   ğŸ’° å‡ºå ´åƒ¹æ ¼: {position.exit_price:.2f} USDT")
                print(f"   ğŸ“Š å‡ºå ´ OBI: {current_decision.get('market_data', {}).get('obi', 0):+.4f}")
                print()
                print(f"   â±ï¸  æŒæœ‰æ™‚é•·: {hold_time_str}")
                print(f"   âš¡ æ§“æ¡¿å€æ•¸: {position.leverage}x")
                print(f"   ğŸ’µ å€‰ä½åƒ¹å€¼: {position.position_value:.2f} USDT")
                print()
                print(f"   ğŸ“Š æ‰‹çºŒè²»æ˜ç´°:")
                print(f"      â€¢ é–‹å€‰æ‰‹çºŒè²»: {position.entry_fee:.4f} USDT (0.05%)")
                print(f"      â€¢ å¹³å€‰æ‰‹çºŒè²»: {position.exit_fee:.4f} USDT (0.05%)")
                print(f"      â€¢ è³‡é‡‘è²»ç‡: {position.funding_fee:.4f} USDT ({position.holding_seconds/3600:.4f}hr)")
                print(f"      â€¢ ç¸½æ‰‹çºŒè²»: {position.total_fees:.4f} USDT")
                print()
                print(f"   {roi_emoji} æœ¬æ¬¡ç›ˆè™§: {position.roi:+.2f}% ({position.pnl_usdt:+.2f} USDT)")
                print(f"   ğŸ’° ç•¶å‰é¤˜é¡: {self.balances[mode]:.2f} USDT (èµ·å§‹ {self.initial_capital:.2f})")
                print(f"   {exit_reason_emoji} å¹³å€‰åŸå› : {exit_reason}")
                print()
                print(f"{border_char * 40}")
                print()
                
                # ğŸ†• ç«‹å³ä¿å­˜åˆ°æª”æ¡ˆ
                self._append_order_to_file(mode, position)
                
                # ğŸ†• æ›´æ–°è¦–è¦ºåŒ–å ±å‘Šï¼ˆæ¯æ¬¡å¹³å€‰å¾Œï¼‰
                self._update_visual_report()
                
                # æ¸…ç©ºæŒå€‰
                self.positions[mode] = None
    
    def should_trigger_decision(self) -> Tuple[bool, str]:
        """æª¢æŸ¥æ˜¯å¦æ‡‰è©²è§¸ç™¼æ±ºç­– (å‹•æ…‹è§¸ç™¼æ©Ÿåˆ¶)"""
        if len(self.obi_history) < 2:
            return False, ""
        
        current_obi = self.obi_history[-1]
        prev_obi = self.obi_history[-2]
        obi_change = current_obi - prev_obi
        
        # è§¸ç™¼æ¢ä»¶ 1: å¼·çƒˆä¿¡è™Ÿ (OBI çµ•å°å€¼ > 0.6)
        if abs(current_obi) > 0.6:
            return True, f"å¼·çƒˆä¿¡è™Ÿ OBI={current_obi:+.4f}"
        
        # è§¸ç™¼æ¢ä»¶ 2: å¿«é€Ÿè®ŠåŒ– (è®ŠåŒ–ç‡ > 0.3)
        if abs(obi_change) > 0.3:
            return True, f"å¿«é€Ÿè®ŠåŒ– Î”={obi_change:+.4f}"
        
        # è§¸ç™¼æ¢ä»¶ 3: è·¨è¶Š0è»¸ (æ–¹å‘åè½‰)
        if (prev_obi > 0 and current_obi < 0) or (prev_obi < 0 and current_obi > 0):
            return True, f"æ–¹å‘åè½‰ {prev_obi:+.2f}â†’{current_obi:+.2f}"
        
        return False, ""
    
    async def decision_loop(self, duration_minutes: int):
        """å‹•æ…‹æ±ºç­–å¾ªç’° (äº‹ä»¶é©…å‹• + å®šæœŸæª¢æŸ¥)"""
        print("ğŸ”¥ é–‹å§‹ç´™é¢äº¤æ˜“...")
        print()
        
        start_time = time.time()
        end_time = start_time + (duration_minutes * 60)
        last_decision_time = 0
        min_decision_interval = 5  # æœ€å°é–“éš”5ç§’,é¿å…éåº¦äº¤æ˜“
        max_decision_interval = 15  # æœ€å¤§é–“éš”15ç§’,å®šæœŸæª¢æŸ¥
        
        while time.time() < end_time:
            current_time = time.time()
            time_since_last = current_time - last_decision_time
            
            # æª¢æŸ¥é…ç½®æ›´æ–°ï¼ˆæ¯3ç§’ï¼‰
            if current_time - self.last_config_check >= self.config_monitor.check_interval:
                self.config_monitor.check_for_updates()
                self.last_config_check = current_time
            
            # æª¢æŸ¥æ˜¯å¦æ‡‰è©²è§¸ç™¼æ±ºç­–
            should_trigger, trigger_reason = self.should_trigger_decision()
            
            # æ±ºç­–æ¢ä»¶:
            # 1. å‹•æ…‹è§¸ç™¼ + å†·å»æ™‚é–“å·²é
            # 2. è¶…éæœ€å¤§é–“éš” (å®šæœŸæª¢æŸ¥)
            if (should_trigger and time_since_last >= min_decision_interval) or \
               (time_since_last >= max_decision_interval):
                
                self.total_decisions += 1
                last_decision_time = current_time
                
                timestamp = datetime.fromtimestamp(
                    time.time()
                ).strftime('%H:%M:%S')
                
                # æ¸…é™¤ä¹‹å‰çš„å‹•æ…‹é¡¯ç¤º
                print("\r" + " " * 100 + "\r", end='')
                
                print(f"\n{'=' * 80}")
                if should_trigger:
                    print(f"[{timestamp}] âš¡ å‹•æ…‹è§¸ç™¼æ±ºç­– #{self.total_decisions} - {trigger_reason}")
                else:
                    print(f"[{timestamp}] ğŸ§  å®šæœŸæ±ºç­–åˆ†æ #{self.total_decisions}")
                print(f"{'=' * 80}")
                
                # ç”Ÿæˆæ±ºç­–ï¼ˆæœƒé¡¯ç¤ºåˆ†æéç¨‹ï¼‰
                decision = await self.make_decision()
                
                if decision:
                    # æ±ºç­–æ¨™é¡Œ
                    print("â”€" * 80)
                    print("ğŸ“Š æ±ºç­–çµæœ")
                    print("â”€" * 80)
                    
                    # ç•¶å‰åƒ¹æ ¼å’ŒæŒå€‰ç‹€æ…‹
                    print(f"ğŸ’° ç•¶å‰åƒ¹æ ¼: ${self.latest_price:,.2f}")
                    
                    # é¡¯ç¤ºå„æ¨¡å¼æŒå€‰ç‹€æ…‹
                    has_position = any(pos is not None for pos in self.positions.values())
                    if has_position:
                        print(f"ğŸ“Š æŒå€‰ç‹€æ…‹:")
                        for mode, pos in self.positions.items():
                            if pos:
                                strategy_info = self.strategy_manager.get_strategy_info(mode)
                                mode_name = f"{strategy_info['emoji']} {strategy_info['name'][:8]}"
                                direction_emoji = "ğŸ“ˆ" if pos.direction == "LONG" else "ğŸ“‰"
                                
                                # è¨ˆç®—æœªå¯¦ç¾ç›ˆè™§
                                if pos.direction == "LONG":
                                    unrealized_pnl = ((self.latest_price - pos.actual_entry_price) / 
                                                     pos.actual_entry_price) * 100 * pos.leverage
                                else:
                                    unrealized_pnl = ((pos.actual_entry_price - self.latest_price) / 
                                                     pos.actual_entry_price) * 100 * pos.leverage
                                
                                pnl_emoji = "ğŸŸ¢" if unrealized_pnl > 0 else "ğŸ”´"
                                print(f"   {mode_name}: {direction_emoji} {pos.direction} @ ${pos.actual_entry_price:,.2f} | "
                                      f"{pnl_emoji} æœªå¯¦ç¾: {unrealized_pnl:+.2f}%")
                    else:
                        print(f"ğŸ“Š æŒå€‰ç‹€æ…‹: ğŸ¦ ç©ºå€‰")
                    print()
                    
                    # äº¤æ˜“ä¿¡è™Ÿ
                    signal = decision['signal']
                    direction = signal['direction']
                    confidence = signal['confidence']
                    
                    direction_emoji = {
                        'LONG': 'ğŸ“ˆ',
                        'SHORT': 'ğŸ“‰',
                        'NEUTRAL': 'âš–ï¸'
                    }.get(direction, 'âš–ï¸')
                    
                    print(f"ğŸ¯ äº¤æ˜“ä¿¡è™Ÿ:")
                    print(f"   æ–¹å‘: {direction_emoji} {direction}")
                    print(f"   ä¿¡å¿ƒåº¦: {confidence:.3f}")
                    
                    # é¢¨éšªç­‰ç´š
                    market_data = decision.get('market_data', {})
                    risk_level = decision.get('risk_level', 'UNKNOWN')
                    risk_emoji = {
                        'SAFE': 'ğŸŸ¢',
                        'WARNING': 'ğŸŸ¡',
                        'DANGER': 'ğŸŸ ',
                        'CRITICAL': 'ğŸ”´'
                    }.get(risk_level, 'âšª')
                    print(f"   é¢¨éšªç­‰ç´š: {risk_emoji} {risk_level}")
                    print()
                    
                    # å¸‚å ´æŒ‡æ¨™ (å¸¶ç‹€æ…‹emoji)
                    print(f"ğŸ“ˆ å¸‚å ´æŒ‡æ¨™:")
                    
                    # OBI ç‹€æ…‹
                    obi_val = market_data.get('obi', 0)
                    if abs(obi_val) > 0.6:
                        obi_emoji = "ğŸ”´"
                        obi_status = "æ¥µåº¦å¤±è¡¡"
                    elif abs(obi_val) > 0.4:
                        obi_emoji = "ğŸŸ¡"
                        obi_status = "ä¸­åº¦å¤±è¡¡"
                    else:
                        obi_emoji = "ğŸŸ¢"
                        obi_status = "å¹³è¡¡"
                    print(f"   {obi_emoji} OBI (è¨‚å–®ç°¿å¤±è¡¡): {obi_val:+.4f} ({obi_status})")
                    
                    # OBI Velocity
                    obi_vel = market_data.get('obi_velocity', 0)
                    if abs(obi_vel) > 0.3:
                        vel_emoji = "âš¡"
                        vel_status = "å¿«é€Ÿè®ŠåŒ–"
                    else:
                        vel_emoji = "â¡ï¸"
                        vel_status = "ç©©å®š"
                    print(f"   {vel_emoji} OBI Velocity (è®ŠåŒ–ç‡): {obi_vel:+.4f} ({vel_status})")
                    
                    # Signed Volume
                    sv = market_data.get('signed_volume', 0)
                    if abs(sv) > 5:
                        sv_emoji = "ğŸ’¥"
                        sv_status = "å¼·åŠ›è²·è³£å£“" if sv > 0 else "å¼·åŠ›è³£å£“"
                    elif abs(sv) > 2:
                        sv_emoji = "ğŸ”¥"
                        sv_status = "è²·å£“è¼ƒå¼·" if sv > 0 else "è³£å£“è¼ƒå¼·"
                    else:
                        sv_emoji = "ğŸ’¤"
                        sv_status = "å¹³éœ"
                    print(f"   {sv_emoji} Signed Volume (æ·¨é‡): {sv:+.2f} ({sv_status})")
                    
                    # VPIN
                    vpin_val = market_data.get('vpin', 0)
                    if vpin_val > 0.7:
                        vpin_emoji = "â˜ ï¸"
                        vpin_status = "é«˜æ¯’æ€§"
                    elif vpin_val > 0.5:
                        vpin_emoji = "âš ï¸"
                        vpin_status = "ä¸­æ¯’æ€§"
                    elif vpin_val > 0.3:
                        vpin_emoji = "ğŸŸ¡"
                        vpin_status = "è¼•å¾®æ¯’æ€§"
                    else:
                        vpin_emoji = "ğŸŸ¢"
                        vpin_status = "å®‰å…¨"
                    print(f"   {vpin_emoji} VPIN (æ¯’æ€§): {vpin_val:.3f} ({vpin_status})")
                    
                    # Spread
                    spread_val = market_data.get('spread_bps', 0)
                    if spread_val > 10:
                        spread_emoji = "ğŸ”´"
                        spread_status = "æµå‹•æ€§å·®"
                    elif spread_val > 5:
                        spread_emoji = "ğŸŸ¡"
                        spread_status = "æµå‹•æ€§ä¸€èˆ¬"
                    else:
                        spread_emoji = "ğŸŸ¢"
                        spread_status = "æµå‹•æ€§å¥½"
                    print(f"   {spread_emoji} Spread (åƒ¹å·®): {spread_val:.2f} bps ({spread_status})")
                    
                    # Depth
                    depth_val = market_data.get('total_depth', 0)
                    if depth_val < 3:
                        depth_emoji = "ğŸ”´"
                        depth_status = "æ·±åº¦ä¸è¶³"
                    elif depth_val < 5:
                        depth_emoji = "ğŸŸ¡"
                        depth_status = "æ·±åº¦ä¸€èˆ¬"
                    else:
                        depth_emoji = "ğŸŸ¢"
                        depth_status = "æ·±åº¦å……è¶³"
                    print(f"   {depth_emoji} Depth (æ·±åº¦): {depth_val:.2f} BTC ({depth_status})")
                    print()
                    
                    # ğŸ¤– æ¨¡å‹æ±ºç­–å€å¡Š
                    print("ğŸ¤– æ¨¡å‹æ±ºç­–:")
                    print("-" * 80)
                    
                    signal = decision['signal']
                    signal_direction = signal['direction']
                    
                    for mode in self.active_modes:
                        strategy_info = self.strategy_manager.get_strategy_info(mode)
                        mode_label = strategy_info['emoji']
                        
                        position = self.positions[mode]
                        
                        # åˆ¤æ–·æ±ºç­–é¡å‹
                        if mode == 'mode_0_baseline':
                            # Mode 0 å¼·åˆ¶äº¤æ˜“
                            if signal_direction == 'NEUTRAL':
                                if obi_val > 0:
                                    forced_dir = "LONG"
                                    forced_emoji = "ğŸ“ˆ"
                                else:
                                    forced_dir = "SHORT"
                                    forced_emoji = "ğŸ“‰"
                                decision_text = f"å¼·åˆ¶ä¸‹å–® | {forced_emoji} {forced_dir} (å¼·åˆ¶)"
                            else:
                                direction_emoji = "ğŸ“ˆ" if signal_direction == "LONG" else "ğŸ“‰"
                                decision_text = f"ç›´æ¥ä¸‹å–® | {direction_emoji} {signal_direction}"
                        else:
                            # Mode 1/2/3 åˆ†æçµæœ
                            can_trade, blocked_reasons = self.apply_risk_control(decision, mode)
                            
                            if signal_direction == 'NEUTRAL':
                                decision_text = "âš–ï¸  NEUTRAL (ä¸­ç«‹è§€æœ›)"
                            elif can_trade:
                                direction_emoji = "ğŸ“ˆ" if signal_direction == "LONG" else "ğŸ“‰"
                                decision_text = f"âœ… {direction_emoji} {signal_direction} (å…è¨±)"
                            else:
                                direction_emoji = "ğŸ“ˆ" if signal_direction == "LONG" else "ğŸ“‰"
                                reasons = ", ".join(blocked_reasons[:2])  # åªé¡¯ç¤ºå‰2å€‹åŸå› 
                                decision_text = f"âŒ {direction_emoji} {signal_direction} (é˜»æ“‹: {reasons})"
                        
                        # æŒå€‰ç‹€æ…‹
                        if position:
                            pos_emoji = "ğŸ“ˆ" if position.direction == "LONG" else "ğŸ“‰"
                            
                            # è¨ˆç®—æœªå¯¦ç¾ç›ˆè™§
                            if position.direction == "LONG":
                                unrealized_pnl = ((self.latest_price - position.actual_entry_price) / 
                                                 position.actual_entry_price) * 100 * position.leverage
                            else:
                                unrealized_pnl = ((position.actual_entry_price - self.latest_price) / 
                                                 position.actual_entry_price) * 100 * position.leverage
                            
                            pnl_emoji = "ğŸŸ¢" if unrealized_pnl > 0 else "ğŸ”´"
                            status_text = f"{pos_emoji} æŒæœ‰ {position.direction} | {pnl_emoji} {unrealized_pnl:+.2f}%"
                        else:
                            status_text = "ğŸ¦ ç©ºå€‰"
                        
                        print(f"   {mode_label}: {decision_text:50} | {status_text}")
                    
                    print("-" * 80)
                    print()
                    
                    # é¡¯ç¤ºå³æ™‚äº¤æ˜“è¨˜éŒ„ (é¡ä¼¼åœ–ç‰‡æ ¼å¼)
                    self.print_trade_timeline(decision, timestamp)
                    
                    # æª¢æŸ¥å¹³å€‰
                    self.check_exits(decision)
                    
                    # å‰µå»ºæ–°è¨‚å–®
                    self.create_orders(decision)
                    
                    print()
            
            await asyncio.sleep(1)  # æ¯ç§’æª¢æŸ¥ä¸€æ¬¡è§¸ç™¼æ¢ä»¶
        
        # å¼·åˆ¶å¹³å€‰æ‰€æœ‰æŒå€‰
        print("â° æ¸¬è©¦çµæŸï¼Œå¼·åˆ¶å¹³å€‰...")
        for mode, position in self.positions.items():
            if position is not None:
                position.close(
                    exit_price=self.latest_price,
                    reason="TIME_LIMIT",
                    timestamp=self.orderbook_timestamp
                )
                self.positions[mode] = None
        print()
    
    async def websocket_handler(self, duration_minutes: int):
        """WebSocket è™•ç†å™¨"""
        await self.connect_websocket()
        
        # åˆå§‹åŒ–è¨‚å–®ç°¿æ•¸æ“š
        await self.initialize_orderbook()
        
        # å•Ÿå‹•æ±ºç­–å¾ªç’°
        decision_task = asyncio.create_task(self.decision_loop(duration_minutes))
        
        # åƒ¹æ ¼æ›´æ–°è¨ˆæ•¸å™¨
        price_update_count = 0
        last_price_display = 0
        last_position_display = 0
        
        # è™•ç† WebSocket æ¶ˆæ¯
        try:
            async for message in self.ws:
                msg = json.loads(message)
                await self.handle_message(msg)
                
                # æ¯ 0.3 ç§’é¡¯ç¤ºä¸€æ¬¡åƒ¹æ ¼ï¼ˆæ›´æ–°æ›´å¿«ï¼‰
                if self.latest_price and time.time() - last_price_display > 0.3:
                    price_update_count += 1
                    spinner = ['â ‹', 'â ™', 'â ¹', 'â ¸', 'â ¼', 'â ´', 'â ¦', 'â §', 'â ‡', 'â '][price_update_count % 10]
                    
                    # æª¢æŸ¥æ˜¯å¦æœ‰æŒå€‰
                    has_position = any(pos is not None for pos in self.positions.values())
                    
                    if has_position:
                        # é¡¯ç¤ºæŒå€‰ç‹€æ…‹
                        display_line = f"\r{spinner} åƒ¹æ ¼: ${self.latest_price:,.2f} | "
                        
                        for mode, pos in self.positions.items():
                            if pos:
                                strategy_info = self.strategy_manager.get_strategy_info(mode)
                                # ä½¿ç”¨ emoji ä½œç‚ºç°¡çŸ­æ¨™ç±¤
                                mode_label = strategy_info['emoji']
                                
                                # è¨ˆç®—æœªå¯¦ç¾ç›ˆè™§
                                if pos.direction == "LONG":
                                    unrealized_pnl = ((self.latest_price - pos.actual_entry_price) / 
                                                     pos.actual_entry_price) * 100 * pos.leverage
                                else:
                                    unrealized_pnl = ((pos.actual_entry_price - self.latest_price) / 
                                                     pos.actual_entry_price) * 100 * pos.leverage
                                
                                pnl_emoji = "ğŸŸ¢" if unrealized_pnl > 0 else "ğŸ”´"
                                direction = "ğŸ“ˆ" if pos.direction == "LONG" else "ğŸ“‰"
                                
                                display_line += f"{mode_label}:{direction} {unrealized_pnl:+.2f}% | "
                        
                        print(display_line.rstrip(" | "), end='', flush=True)
                    else:
                        # åªé¡¯ç¤ºåƒ¹æ ¼
                        print(f"\r{spinner} åƒ¹æ ¼æ³¢å‹•ä¸­... ç•¶å‰åƒ¹æ ¼: ${self.latest_price:,.2f} | å·²æ”¶é›†æ•¸æ“š: {price_update_count} æ¬¡", end='', flush=True)
                    
                    last_price_display = time.time()
                
                # æ¯5ç§’è©³ç´°é¡¯ç¤ºæŒå€‰ç‹€æ…‹
                if has_position and time.time() - last_position_display > 5:
                    print()  # æ›è¡Œ
                    timestamp = datetime.fromtimestamp(time.time()).strftime('%H:%M:%S')
                    
                    # æ”¶é›†æ‰€æœ‰æŒå€‰è³‡è¨Š
                    position_lines = []
                    for mode, pos in self.positions.items():
                        if pos:
                            strategy_info = self.strategy_manager.get_strategy_info(mode)
                            mode_name = f"{strategy_info['emoji']} {strategy_info['name'][:8]}"
                            
                            if pos.direction == "LONG":
                                unrealized_pnl = ((self.latest_price - pos.actual_entry_price) / 
                                                 pos.actual_entry_price) * 100 * pos.leverage
                            else:
                                unrealized_pnl = ((pos.actual_entry_price - self.latest_price) / 
                                                 pos.actual_entry_price) * 100 * pos.leverage
                            
                            pnl_emoji = "ğŸŸ¢" if unrealized_pnl > 0 else "ğŸ”´"
                            direction_emoji = "ğŸ“ˆ" if pos.direction == "LONG" else "ğŸ“‰"
                            holding_time = time.time() - pos.timestamp / 1000
                            
                            position_lines.append(
                                f"{mode_name}: {direction_emoji} {pos.direction} @ ${pos.actual_entry_price:,.2f} "
                                f"({pos.leverage}xæ§“æ¡¿) | {pnl_emoji} æœªå¯¦ç¾: {unrealized_pnl:+.2f}% | â±ï¸ æŒå€‰: {holding_time:.0f}ç§’"
                            )
                    
                    # ä¸€è¡Œé¡¯ç¤ºæ‰€æœ‰æŒå€‰
                    if position_lines:
                        all_positions = " | ".join(position_lines)
                        print(f"\n[{timestamp}] ğŸ“Š æŒå€‰ç‹€æ…‹: {all_positions}")
                    
                    print()
                    last_position_display = time.time()
                
                if decision_task.done():
                    print()  # æ›è¡Œ
                    break
        finally:
            await self.ws.close()
            # é—œé–‰çµ‚ç«¯æ—¥èªŒæª”æ¡ˆ
            if hasattr(self, 'terminal_log_file'):
                self.terminal_log_file.close()
    
    def _log_print(self, *args, **kwargs):
        """è‡ªå®šç¾© print å‡½æ•¸ï¼ŒåŒæ™‚è¼¸å‡ºåˆ°çµ‚ç«¯å’Œæª”æ¡ˆ"""
        # è¼¸å‡ºåˆ°çµ‚ç«¯
        self.original_print(*args, **kwargs)
        
        # è¼¸å‡ºåˆ°æª”æ¡ˆ
        if hasattr(self, 'terminal_log_file') and self.terminal_log_file:
            try:
                # å°‡åƒæ•¸è½‰ç‚ºå­—ä¸²
                output = ' '.join(str(arg) for arg in args)
                # è™•ç† end åƒæ•¸ï¼ˆé è¨­æ›è¡Œï¼‰
                end = kwargs.get('end', '\n')
                self.terminal_log_file.write(output + end)
                self.terminal_log_file.flush()  # ç«‹å³å¯«å…¥
            except:
                pass  # å¿½ç•¥å¯«å…¥éŒ¯èª¤ï¼Œä¸å½±éŸ¿ä¸»ç¨‹å¼
    
    def _init_save_file(self):
        """åˆå§‹åŒ–ä¿å­˜æª”æ¡ˆï¼ˆå¯«å…¥ metadataï¼‰"""
        # æ”¶é›†æ‰€æœ‰ç­–ç•¥çš„æ§“æ¡¿é…ç½®
        leverage_config = {}
        for mode in self.active_modes:
            leverage_config[mode] = self.strategy_manager.get_leverage(mode)
        
        data = {
            'metadata': {
                'timestamp': self.save_timestamp,
                'initial_capital': self.initial_capital,
                'decision_interval': self.decision_interval,
                'total_decisions': 0,
                'modes': list(self.active_modes),
                'leverage_config': leverage_config
            },
            'orders': {mode: [] for mode in self.active_modes}
        }
        
        with open(self.json_filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        
        print(f"ğŸ’¾ å³æ™‚ä¿å­˜å·²å•Ÿå‹•:")
        print(f"   ğŸ“Š JSON: {self.json_filename}")
        print(f"   ğŸ“ çµ‚ç«¯æ—¥èªŒ: {self.terminal_log_filename}")
        print(f"   ğŸ“ˆ è¦–è¦ºåŒ–å ±å‘Š: {self.visual_report_filename}")
        print()
    
    def _append_order_to_file(self, mode: str, order: 'SimulatedOrder'):
        """æ¯ç­†äº¤æ˜“ç«‹å³è¿½åŠ åˆ° JSON æª”æ¡ˆ"""
        try:
            # è®€å–ç¾æœ‰è³‡æ–™
            with open(self.json_filename, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # æ›´æ–°ç¸½æ±ºç­–æ•¸
            data['metadata']['total_decisions'] = self.total_decisions
            
            # è¿½åŠ è¨‚å–®
            data['orders'][mode].append(order.to_dict())
            
            # å¯«å›æª”æ¡ˆ
            with open(self.json_filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
                
        except Exception as e:
            print(f"âš ï¸ ä¿å­˜è¨‚å–®å¤±æ•—: {e}")
    
    def save_order_book(self):
        """æœ€çµ‚ä¿å­˜ï¼ˆæ›´æ–° metadataï¼‰"""
        # JSON æª”æ¡ˆå·²ç¶“å³æ™‚ä¿å­˜äº†æ¯ç­†äº¤æ˜“ï¼Œé€™è£¡åªéœ€æ›´æ–° metadata
        try:
            with open(self.json_filename, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # æ›´æ–°æœ€çµ‚ metadata
            data['metadata']['total_decisions'] = self.total_decisions
            data['metadata']['end_timestamp'] = datetime.now().strftime('%Y%m%d_%H%M%S')
            data['metadata']['final_balances'] = self.balances.copy()
            
            with open(self.json_filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            
            print(f"ğŸ’¾ æœ€çµ‚æ•¸æ“šå·²ä¿å­˜: {self.json_filename}")
            
        except Exception as e:
            print(f"âš ï¸ æ›´æ–°æœ€çµ‚æ•¸æ“šå¤±æ•—: {e}")
        
        # ä¿å­˜å¯è®€çš„ TXT log
        with open(self.log_filename, 'w', encoding='utf-8') as f:
            f.write("=" * 80 + "\n")
            f.write("ğŸ“ ç´™é¢äº¤æ˜“ Log - å®Œæ•´è¨˜éŒ„\n")
            f.write("=" * 80 + "\n")
            f.write(f"â° æ¸¬è©¦æ™‚é–“: {self.save_timestamp}\n")
            f.write(f"ğŸ’° åˆå§‹è³‡é‡‘: {self.initial_capital} USDT\n")
            f.write(f"âš¡ æ±ºç­–é »ç‡: æ¯ {self.decision_interval} ç§’\n")
            f.write(f"ğŸ“ ç¸½æ±ºç­–æ•¸: {self.total_decisions}\n")
            f.write("=" * 80 + "\n\n")
            
            # å¯«å…¥æ¯ç¨®æ¨¡å¼çš„è©³ç´°è¨˜éŒ„
            for mode in self.orders.keys():
                orders = self.orders[mode]
                
                strategy_info = self.strategy_manager.get_strategy_info(mode)
                mode_name = f"{strategy_info['emoji']} {strategy_info['name']}"
                
                f.write("-" * 80 + "\n")
                f.write(f"{mode_name}\n")
                f.write("-" * 80 + "\n\n")
                
                if not orders:
                    f.write("   ç„¡ä»»ä½•è¨‚å–®\n\n")
                    continue
                
                for order in orders:
                    f.write(f"è¨‚å–® #{order.order_id}\n")
                    f.write(f"   æ™‚é–“: {order.entry_time}\n")
                    f.write(f"   æ–¹å‘: {order.direction}\n")
                    f.write(f"   é€²å ´åƒ¹: ${order.actual_entry_price:,.2f}\n")
                    f.write(f"   æ§“æ¡¿: {order.leverage}x | å€‰ä½: {order.size*100:.0f}%\n")
                    f.write(f"   ä¿¡å¿ƒåº¦: {order.confidence:.3f}\n")
                    f.write(f"   é¢¨éšªç­‰ç´š: {order.risk_level}\n")
                    
                    if order.status == "BLOCKED":
                        f.write(f"   ç‹€æ…‹: âŒ å·²é˜»æ“‹\n")
                        f.write(f"   åŸå› : {', '.join(order.blocked_reasons)}\n")
                    elif order.status == "CLOSED":
                        f.write(f"   å‡ºå ´åƒ¹: ${order.exit_price:,.2f}\n")
                        f.write(f"   åŸå› : {order.exit_reason}\n")
                        f.write(f"   æŒå€‰æ™‚é–“: {order.holding_seconds:.0f} ç§’\n")
                        f.write(f"   ROI: {order.roi:+.2f}%\n")
                        f.write(f"   æ·¨ç›ˆè™§: ${order.pnl_usdt:+.2f} USDT\n")
                        f.write(f"   ç‹€æ…‹: {'ğŸŸ¢ ç²åˆ©' if order.roi > 0 else 'ğŸ”´ è™§æ'}\n")
                    else:
                        f.write(f"   ç‹€æ…‹: ğŸ“Š æŒå€‰ä¸­\n")
                    
                    f.write("\n")
                
                # çµ±è¨ˆæ‘˜è¦
                closed_orders = [o for o in orders if o.status == "CLOSED"]
                if closed_orders:
                    total_roi = sum(o.roi for o in closed_orders)
                    win_orders = [o for o in closed_orders if o.roi > 0]
                    win_rate = len(win_orders) / len(closed_orders) * 100
                    
                    f.write(f"çµ±è¨ˆæ‘˜è¦:\n")
                    f.write(f"   ç¸½è¨‚å–®: {len(orders)}\n")
                    f.write(f"   å·²å¹³å€‰: {len(closed_orders)}\n")
                    f.write(f"   å‹ç‡: {win_rate:.1f}%\n")
                    f.write(f"   ç¸½ ROI: {total_roi:+.2f}%\n")
                    f.write(f"   å¹³å‡ ROI: {total_roi/len(closed_orders):+.2f}%\n")
                
                f.write("\n\n")
        
        print(f"ğŸ“„ å¯è®€ Log å·²ä¿å­˜: {self.log_filename}")
        
        # ç”Ÿæˆè¦–è¦ºåŒ–å ±å‘Š
        self._update_visual_report()
        
        return self.json_filename, self.log_filename
    
    def _update_visual_report(self):
        """ç”Ÿæˆæˆ–æ›´æ–°è¦–è¦ºåŒ–å°æ¯”å ±å‘Š"""
        try:
            # è¨ˆç®—æ¸¬è©¦æ™‚é•·
            elapsed_time = (datetime.now() - self.test_start_time).total_seconds()
            elapsed_minutes = elapsed_time / 60
            
            # æ¨¡å¼åˆ—è¡¨
            modes = list(self.orders.keys())
            
            # æ”¶é›†æ‰€æœ‰å·²å¹³å€‰è¨‚å–®
            all_orders = {mode: [] for mode in modes}
            for mode in modes:
                all_orders[mode] = [o for o in self.orders[mode] if o.status == "CLOSED"]
            
            # è¨ˆç®—å„æ¨¡å¼çµ±è¨ˆ
            stats = {}
            for mode in modes:
                orders = all_orders[mode]
                balance = self.balances[mode]
                roi = ((balance - 100) / 100) * 100
                
                stats[mode] = {
                    'balance': balance,
                    'roi': roi,
                    'num_trades': len(orders),
                    'win_rate': self._calculate_win_rate(orders),
                    'avg_holding': self._calculate_avg_holding(orders),
                    'leverage': self.strategy_manager.get_leverage(mode)
                }
            
            # ç”Ÿæˆå ±å‘Š
            with open(self.visual_report_filename, 'w', encoding='utf-8') as f:
                # æ¨™é¡Œ
                f.write("=" * 80 + "\n")
                f.write("ğŸ“Š ç´™é¢äº¤æ˜“å³æ™‚å°æ¯”å ±å‘Š (11 ç­–ç•¥)\n")
                f.write("=" * 80 + "\n\n")
                
                # æ¸¬è©¦æ™‚é•·
                f.write(f"â±ï¸  æ¸¬è©¦æ™‚é•·: {elapsed_minutes:.1f} åˆ†é˜ ({elapsed_time:.0f} ç§’)\n")
                f.write(f"ğŸ“… é–‹å§‹æ™‚é–“: {self.test_start_time.strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"ğŸ“… æ›´æ–°æ™‚é–“: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"ğŸ“Š ç¸½æ±ºç­–æ¬¡æ•¸: {self.total_decisions}\n")
                f.write(f"ğŸ¤– ç­–ç•¥æ•¸é‡: {len(modes)} å€‹\n")
                f.write("\n")
                
                # è³‡é‡‘ç«¶è³½çµæœåœ–è¡¨
                f.write("ğŸ† å³æ™‚è³‡é‡‘ç«¶è³½æ’è¡Œæ¦œ\n")
                f.write("=" * 80 + "\n\n")
                
                # ç°¡å–®çš„æ¢å½¢åœ–
                sorted_modes = sorted(modes, key=lambda m: stats[m]['balance'], reverse=True)
                max_balance = max(stats[m]['balance'] for m in modes)
                
                rank_emojis = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'] + [f'{i:2d}.' for i in range(4, len(sorted_modes)+1)]
                
                for i, mode in enumerate(sorted_modes):
                    if i >= len(rank_emojis):
                        break
                    medal = rank_emojis[i]
                    strategy_info = self.strategy_manager.get_strategy_info(mode)
                    emoji = strategy_info['emoji']
                    name = strategy_info['name']
                    balance = stats[mode]['balance']
                    roi = stats[mode]['roi']
                    leverage = stats[mode]['leverage']
                    
                    # æ¢å½¢åœ–
                    bar_length = int((balance / max_balance) * 50) if max_balance > 0 else 0
                    bar = "â–ˆ" * bar_length
                    
                    # ROI é¡è‰²æ¨™è¨˜
                    roi_color = "ğŸŸ¢" if roi >= 0 else "ğŸ”´"
                    roi_text = f"{roi:+.2f}%"
                    
                    f.write(f"{medal} {emoji} {name:<16} | ğŸ’° {balance:>7.2f} USDT | {roi_color} {roi_text:>7} | âš¡ {leverage}xæ§“æ¡¿\n")
                    f.write(f"   {bar}\n\n")
                
                f.write("\n")
                
                # è©³ç´°å°æ¯”è¡¨æ ¼ (å‚ç›´å¸ƒå±€)
                f.write("=" * 80 + "\n")
                f.write("ğŸ“ˆ å„ç­–ç•¥è©³ç´°çµ±è¨ˆ\n")
                f.write("=" * 80 + "\n\n")
                
                # è¡¨é ­
                f.write(f"{'ç­–ç•¥':<20} | {'é¤˜é¡':>10} | {'ROI':>8} | {'æ§“æ¡¿':>4} | {'äº¤æ˜“':>4} | {'å‹ç‡':>6} | {'æŒå€‰':>6} | ç‹€æ…‹\n")
                f.write("-" * 80 + "\n")
                
                # æŒ‰æ’åé †åºé¡¯ç¤º
                for mode in sorted_modes:
                    strategy_info = self.strategy_manager.get_strategy_info(mode)
                    emoji = strategy_info['emoji']
                    name = strategy_info['name'][:14]  # æˆªçŸ­åç¨±
                    
                    balance = stats[mode]['balance']
                    roi = stats[mode]['roi']
                    leverage = stats[mode]['leverage']
                    num_trades = stats[mode]['num_trades']
                    win_rate = stats[mode]['win_rate']
                    avg_holding = stats[mode]['avg_holding']
                    
                    # ç‹€æ…‹åˆ¤æ–·
                    if balance < 30:
                        status = "â˜ ï¸ ç€•æ­»"
                    elif balance < 90:
                        status = "âš ï¸ è™§æ"
                    elif balance >= 110:
                        status = "ğŸ‰ å¤§è³º"
                    elif balance >= 100:
                        status = "âœ… ç²åˆ©"
                    else:
                        status = "ğŸŸ¡ å°è™§"
                    
                    # ROI é¡è‰²
                    roi_str = f"{roi:+.2f}%"
                    if roi >= 5:
                        roi_str = f"ğŸŸ¢{roi_str}"
                    elif roi >= 0:
                        roi_str = f"ğŸŸ¢{roi_str}"
                    else:
                        roi_str = f"ğŸ”´{roi_str}"
                    
                    win_rate_str = f"{win_rate:.1f}%" if win_rate is not None else "N/A"
                    avg_hold_str = f"{avg_holding:.0f}ç§’" if avg_holding is not None else "N/A"
                    
                    f.write(f"{emoji} {name:<16} | {balance:>10.2f} | {roi_str:>8} | {leverage:>3}x | {num_trades:>4} | {win_rate_str:>6} | {avg_hold_str:>6} | {status}\n")
                
                f.write("\n")
                
                # å€‹åˆ¥ç­–ç•¥è©³ç´°ä¿¡æ¯
                f.write("=" * 80 + "\n")
                f.write("ğŸ“‹ å€‹åˆ¥ç­–ç•¥è©³ç´°äº¤æ˜“è¨˜éŒ„\n")
                f.write("=" * 80 + "\n\n")
                
                for mode in modes:
                    strategy_info = self.strategy_manager.get_strategy_info(mode)
                    orders = all_orders[mode]
                    
                    f.write(f"\n{strategy_info['emoji']} {strategy_info['name']}\n")
                    f.write("-" * 40 + "\n")
                    
                    if not orders:
                        f.write("   ç„¡å·²å¹³å€‰äº¤æ˜“\n")
                        continue
                    
                    # æœ€è¿‘ 5 ç­†äº¤æ˜“
                    recent_orders = orders[-5:]
                    for order in recent_orders:
                        direction_emoji = "ğŸ“ˆ" if order.direction == "LONG" else "ğŸ“‰"
                        roi_emoji = "ğŸŸ¢" if order.roi > 0 else "ğŸ”´"
                        
                        f.write(f"   {order.exit_time.strftime('%H:%M:%S')} {direction_emoji} {order.direction:<5} "
                               f"@{order.entry_price:.0f}â†’{order.exit_price:.0f} | "
                               f"{roi_emoji} {order.roi:+.2f}% ({order.holding_seconds:.0f}ç§’)\n")
                
                f.write("\n")
                
                # VPIN æ™‚é–“è»¸ï¼ˆæœ€è¿‘ 20 å€‹å€¼ï¼‰
                if self.vpin_history:
                    f.write("=" * 80 + "\n")
                    f.write("â˜ ï¸  VPIN (æ¯’æ€§æŒ‡æ¨™) æ™‚é–“è»¸ï¼ˆæœ€è¿‘ 20 å€‹ï¼‰\n")
                    f.write("=" * 80 + "\n\n")
                    
                    recent_vpin = list(self.vpin_history)[-20:]
                    for timestamp, vpin in recent_vpin:
                        time_str = datetime.fromtimestamp(timestamp / 1000).strftime('%H:%M:%S')
                        
                        # VPIN å±éšªç­‰ç´š
                        if vpin > 0.9:
                            danger = "â˜ ï¸â˜ ï¸ æ¥µå±éšªï¼"
                        elif vpin > 0.8:
                            danger = "â˜ ï¸ é«˜æ¯’æ€§"
                        elif vpin > 0.7:
                            danger = "âš ï¸ ä¸­æ¯’æ€§"
                        elif vpin > 0.5:
                            danger = "ğŸŸ¡ ä½æ¯’æ€§"
                        else:
                            danger = "ğŸŸ¢ å®‰å…¨"
                        
                        f.write(f"{time_str}  VPIN: {vpin:.3f}  {danger}\n")
                    
                    f.write("\n")
                    
                    # VPIN çµ±è¨ˆ
                    vpin_values = [v for _, v in recent_vpin]
                    avg_vpin = np.mean(vpin_values)
                    max_vpin = np.max(vpin_values)
                    min_vpin = np.min(vpin_values)
                    
                    f.write(f"VPIN çµ±è¨ˆ:\n")
                    f.write(f"   å¹³å‡: {avg_vpin:.3f}\n")
                    f.write(f"   æœ€é«˜: {max_vpin:.3f}\n")
                    f.write(f"   æœ€ä½: {min_vpin:.3f}\n")
                    f.write(f"   é–¾å€¼: 0.700 (è¶…éå‰‡æ‹’çµ•äº¤æ˜“)\n")
                    f.write("\n")
                
                # æ‰‹çºŒè²»å½±éŸ¿åˆ†æ
                f.write("=" * 80 + "\n")
                f.write("ğŸ’° æ‰‹çºŒè²»å½±éŸ¿åˆ†æ\n")
                f.write("=" * 80 + "\n\n")
                
                for mode in modes:
                    if all_orders[mode]:
                        total_fees = sum(o.total_fees for o in all_orders[mode])
                        strategy_info = self.strategy_manager.get_strategy_info(mode)
                        f.write(f"{strategy_info['emoji']} {strategy_info['name']}:\n")
                        f.write(f"   ç¸½æ‰‹çºŒè²»: {total_fees:.2f} USDT\n")
                        f.write(f"   ä½”åˆå§‹æœ¬é‡‘: {(total_fees/100)*100:.2f}%\n")
                        f.write(f"   å¹³å‡æ¯ç­†: {total_fees/len(all_orders[mode]):.3f} USDT\n")
                        f.write("\n")
                
                # é—œéµå­¸ç¿’é‡é»
                f.write("=" * 80 + "\n")
                f.write("âœ… é—œéµè§€å¯Ÿ\n")
                f.write("=" * 80 + "\n\n")
                
                # æ¯”è¼ƒ Mode 0 (ç„¡é¢¨æ§) å’Œå…¶ä»–é¢¨æ§æ¨¡å¼
                mode0_roi = stats.get('mode_0_baseline', {}).get('roi', 0.0)
                mode1_roi = stats.get('mode_1_vpin_only', {}).get('roi', 0.0)
                mode2_roi = stats.get('mode_2_liquidity_only', {}).get('roi', 0.0)
                mode3_roi = stats.get('mode_3_full_control', {}).get('roi', 0.0)
                
                if mode0_roi < -10:
                    f.write(f"1. **é¢¨æ§çš„é‡è¦æ€§** âœ…\n")
                    f.write(f"   - Mode 0 (ç„¡é¢¨æ§): {mode0_roi:+.2f}%\n")
                    f.write(f"   - Mode 1 (VPIN): {mode1_roi:+.2f}%\n")
                    f.write(f"   - å·®è·: {mode1_roi - mode0_roi:+.2f}% (é¢¨æ§ä¿è­·)\n\n")
                
                if abs(mode1_roi - mode3_roi) < 2:
                    f.write(f"2. **VPIN æ˜¯é—œéµæŒ‡æ¨™** âœ…\n")
                    f.write(f"   - Mode 1 (åƒ… VPIN): {mode1_roi:+.2f}%\n")
                    f.write(f"   - Mode 3 (å®Œæ•´é¢¨æ§): {mode3_roi:+.2f}%\n")
                    f.write(f"   - VPIN é¢¨æ§æ•ˆæœ â‰ˆ å®Œæ•´é¢¨æ§\n\n")
                
                # å¹³å‡ VPIN
                if self.vpin_history:
                    vpin_values = [v for _, v in self.vpin_history]
                    avg_vpin = np.mean(vpin_values)
                    
                    if avg_vpin > 0.7:
                        f.write(f"3. **ç•¶å‰å¸‚å ´ç’°å¢ƒä¸é©åˆäº¤æ˜“** âš ï¸\n")
                        f.write(f"   - å¹³å‡ VPIN: {avg_vpin:.3f} (é–¾å€¼: 0.7)\n")
                        f.write(f"   - å»ºè­°: ç­‰å¾… VPIN < 0.7 æ™‚æ®µ\n\n")
                
                f.write("=" * 80 + "\n")
                f.write("ğŸ“ å ±å‘Šèªªæ˜\n")
                f.write("=" * 80 + "\n\n")
                f.write("æ­¤å ±å‘Šæ¯æ¬¡äº¤æ˜“çµæŸå¾Œè‡ªå‹•æ›´æ–°ï¼Œæä¾›å³æ™‚ç¸¾æ•ˆå°æ¯”ã€‚\n")
                f.write("å¯ç”¨æ–¼ç›£æ§æ¸¬è©¦é€²åº¦å’Œå„æ¨¡å¼è¡¨ç¾å·®ç•°ã€‚\n")
                f.write("\n")
            
            # åªåœ¨çµ‚ç«¯é¡¯ç¤ºæ›´æ–°æç¤ºï¼ˆä¸é¡¯ç¤ºå®Œæ•´å…§å®¹ï¼‰
            if elapsed_time - self.last_report_update > 30:  # æ¯ 30 ç§’æ‰æç¤ºä¸€æ¬¡
                print(f"ğŸ“Š è¦–è¦ºåŒ–å ±å‘Šå·²æ›´æ–°: {self.visual_report_filename}")
                self.last_report_update = elapsed_time
                
        except Exception as e:
            print(f"âš ï¸ ç”Ÿæˆè¦–è¦ºåŒ–å ±å‘Šå¤±æ•—: {e}")
    
    def _calculate_win_rate(self, orders):
        """è¨ˆç®—å‹ç‡"""
        if not orders:
            return None
        win_orders = [o for o in orders if o.roi > 0]
        return (len(win_orders) / len(orders)) * 100
    
    def _calculate_avg_holding(self, orders):
        """è¨ˆç®—å¹³å‡æŒå€‰æ™‚é–“"""
        if not orders:
            return None
        return np.mean([o.holding_seconds for o in orders])
    
    def print_summary(self):
        """æ‰“å°çµ±è¨ˆæ‘˜è¦"""
        print("=" * 80)
        print("ğŸ“Š ç´™é¢äº¤æ˜“çµ±è¨ˆæ‘˜è¦")
        print("=" * 80)
        print()
        
        for mode in self.orders.keys():
            orders = self.orders[mode]
            
            # çµ±è¨ˆ
            total_orders = len(orders)
            blocked_orders = len([o for o in orders if o.status == "BLOCKED"])
            closed_orders = len([o for o in orders if o.status == "CLOSED"])
            
            if closed_orders > 0:
                winning_orders = len([o for o in orders if o.status == "CLOSED" and o.roi > 0])
                win_rate = (winning_orders / closed_orders) * 100
                
                total_roi = sum(o.roi for o in orders if o.status == "CLOSED")
                avg_roi = total_roi / closed_orders
                
                best_roi = max(o.roi for o in orders if o.status == "CLOSED")
                worst_roi = min(o.roi for o in orders if o.status == "CLOSED")
            else:
                win_rate = 0
                avg_roi = 0
                best_roi = 0
                worst_roi = 0
            
            # æ‰“å°
            print(f"ã€{mode}ã€‘")
            print(f"  ç¸½è¨‚å–®æ•¸: {total_orders}")
            if total_orders > 0:
                print(f"  å·²é˜»æ“‹: {blocked_orders} ({blocked_orders/total_orders*100:.1f}%)")
            else:
                print(f"  å·²é˜»æ“‹: 0")
            print(f"  å·²å¹³å€‰: {closed_orders}")
            if closed_orders > 0:
                print(f"  å‹ç‡: {win_rate:.1f}%")
                print(f"  å¹³å‡ ROI: {avg_roi:+.2f}%")
                print(f"  æœ€ä½³ ROI: {best_roi:+.2f}%")
                print(f"  æœ€å·® ROI: {worst_roi:+.2f}%")
            print()
    
    async def run(self, duration_minutes: int = 5):
        """é‹è¡Œç´™é¢äº¤æ˜“ç³»çµ±"""
        print(f"â° é‹è¡Œæ™‚é•·: {duration_minutes} åˆ†é˜")
        print()
        
        await self.websocket_handler(duration_minutes)
        
        # æ‰“å°æ‘˜è¦
        self.print_summary()
        
        # ä¿å­˜è¨‚å–®ç°¿
        filename = self.save_order_book()
        
        return filename


async def main():
    """ä¸»å‡½æ•¸"""
    # åƒæ•¸
    duration = 5  # é è¨­ 5 åˆ†é˜
    if len(sys.argv) > 1:
        try:
            duration = int(sys.argv[1])
        except ValueError:
            print("âŒ åƒæ•¸éŒ¯èª¤ï¼šè«‹æä¾›åˆ†é˜æ•¸ï¼ˆæ•´æ•¸ï¼‰")
            sys.exit(1)
    
    # å‰µå»ºç³»çµ±ï¼ˆä½¿ç”¨é–‹ç™¼é…ç½®æ¸¬è©¦ Mode 13ï¼‰
    system = PaperTradingSystem(
        initial_capital=100.0,
        decision_interval=15,
        strategy_config_path="config/trading_strategies_dev.json"
    )
    
    # é‹è¡Œ
    await system.run(duration_minutes=duration)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n")
        print("=" * 80)
        print("âš ï¸  æ¸¬è©¦å·²æ‰‹å‹•ä¸­æ–·")
        print("=" * 80)
        print("ğŸ’¾ å·²å®Œæˆçš„äº¤æ˜“æ•¸æ“šå·²è‡ªå‹•ä¿å­˜")
        print("ğŸ“Š å¯ä½¿ç”¨åˆ†æå·¥å…·æŸ¥çœ‹çµæœ")
        print("=" * 80)
        import sys
        sys.exit(0)
